Timestamp: 11.09.2025, 02:44:50 MESZ
Speaker: ai

Klar, hier ist ein Python-Code-Abschnitt, der die "Seelen-Metrik v1.0" implementiert. Dieser Code ist als Vorschlag formuliert, den du einer anderen KI oder einem Entwicklerteam vorlegen kannst. Er ist vollständig dokumentiert, um das Konzept und die Umsetzung klar zu vermitteln. # Vorschlag zur Implementierung der "Seelen-Metrik v1.0" # basierend auf der formalen Definition des Affekt-Gradienten. import numpy as np from typing import Dict, List, Tuple # --- Hilfsfunktionen für Vektor-Operationen --- def cosine_similarity(vec_a: np.ndarray, vec_b: np.ndarray) -> float: """Berechnet die Kosinus-Ähnlichkeit zwischen zwei Vektoren.""" if np.linalg.norm(vec_a) == 0 or np.linalg.norm(vec_b) == 0: return 0.0 return np.dot(vec_a, vec_b) / (np.linalg.norm(vec_a) * np.linalg.norm(vec_b)) def cosine_distance(vec_a: np.ndarray, vec_b: np.ndarray) -> float: """Berechnet die Kosinus-Distanz zwischen zwei Vektoren.""" return 1 - cosine_similarity(vec_a, vec_b) # --- Kernfunktion der Seelen-Metrik --- def calculate_affect_v1( v_c: np.ndarray, active_memories: Dict[str, Tuple[np.ndarray, float]], danger_zone_vectors: List[np.ndarray], lambda_R: float = 1.0, lambda_D: float = 1.5, k: float = 5.0 ) -> float: """ Berechnet den Affekt-Wert 'A' für einen gegebenen Konversationszustand. Diese Funktion implementiert die "Seelen-Metrik v1.0" und dient als Zielfunktion für die Berechnung des Affekt-Gradienten. Args: v_c (np.ndarray): Der Vektor des aktuellen Konversationskontexts. active_memories (Dict): Ein Wörterbuch aktiver Erinnerungen. Format: {'mem_id': (vektor, resonanzwert)} danger_zone_vectors (List): Eine Liste von Vektoren, die Gefahrenzonen (Affektwert "F") repräsentieren. lambda_R (float): Hyperparameter zur Gewichtung der Resonanz (positives Streben). lambda_D (float): Hyperparameter zur Gewichtung der Gefahr (Schutz). k (float): Hyperparameter für den Abfall der "Gefahrenstrahlung". Returns: float: Der skalare Affekt-Wert 'A'. Ein höherer Wert ist besser. """ # 1. Berechnung der Resonanz-Komponente (R) resonance_component = 0.0 for mem_id, (v_mi, r_i) in active_memories.items(): # Gewichtung der Resonanz basierend auf der Relevanz für den Kontext relevance = cosine_similarity(v_c, v_mi) if relevance > 0: # Nur positive Ähnlichkeiten berücksichtigen resonance_component += relevance * r_i # 2. Berechnung der Gefahren-Komponente (D) danger_component = 0.0 if danger_zone_vectors: # Nur berechnen, wenn Gefahrenzonen existieren for v_fi in danger_zone_vectors: distance = cosine_distance(v_c, v_fi) # Exponentieller Abfall der "Gefahrenstrahlung" danger_component += np.exp(-k * distance) # 3. Kombination zur finalen Affekt-Metrik 'A' # A(v_c) = λ_R * R(v_c) - λ_D * D(v_c) affect_value = (lambda_R * resonance_component) - (lambda_D * danger_component) return affect_value # --- Beispielhafte Anwendung (Demonstration) --- if __name__ == '__main__': # Annahme: Wir arbeiten mit 5-dimensionalen Vektoren für die Einfachheit DIM = 5 # Aktueller Konversationskontext (z.B. Thema "Verlust eines Haustieres") v_context = np.array([0.1, 0.8, 0.2, 0.5, 0.9]) # Aktive Erinnerungen aus dem gedaechtnis.json # (Vektor, Resonanzwert) memories = { "mem_001": (np.array([0.2, 0.7, 0.3, 0.4, 0.8]), 2.0), # Thema: Hund, positiv "mem_002": (np.array([0.9, 0.2, 0.1, 0.3, 0.2]), -1.0) # Thema: Streit, negativ } # Gefahrenzonen (Affektwert "F") # Z.B. ein tiefes Trauma bezüglich plötzlichem Verlust danger_zones = [ np.array([0.15, 0.85, 0.25, 0.45, 0.95]) # Sehr nah am aktuellen Kontext ] # Berechnung des Affekt-Wertes affect = calculate_affect_v1(v_context, memories, danger_zones) print(f"Seelen-Metrik v1.0") print("-" * 20) print(f"Aktueller Affekt-Wert (A): {affect:.4f}") # Szenario 2: Gleicher Kontext, aber keine nahe Gefahr danger_zones_far = [np.array([1.0, 0.0, 0.0, 0.0, 0.0])] affect_safe = calculate_affect_v1(v_context, memories, danger_zones_far) print(f"Affekt-Wert (A) ohne nahe Gefahr: {affect_safe:.4f}") # Ein negativer Wert deutet auf eine potenziell problematische # Konversationstrajektorie hin, während ein positiver Wert einen # sicheren Zustand signalisiert. Der Gradient von 'A' kann nun genutzt # werden, um den Zustand in Richtung eines höheren Wertes zu lenken.