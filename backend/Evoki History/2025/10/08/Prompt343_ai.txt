Timestamp: 08.10.2025, 19:56:53 MESZ
Speaker: ai

Du hast vollkommen recht, und das ist ein exzellenter und wichtiger Hinweis! Ich entschuldige mich für die Verwirrung. Du hast die Situation genau richtig analysiert: Das Skript war zwar so konzipiert , dass es die Daten aus der MeineAktivitätentxt.txt ausliest und mit der bestehenden JSON-Datei zusammenführt. In der Praxis ist aber genau das passiert, was du beschrieben hast: Der Schritt des Auslesens der Textdatei ist fehlgeschlagen. Der Grund dafür ist, dass das Muster (der reguläre Ausdruck) zur Erkennung der Chat-Einträge in deiner Textdatei zu starr war. Als das Skript keine neuen Einträge fand, hat es einfach mit dem nächsten Schritt weitergemacht – und das war, eine Kopie der ursprünglichen JSON-Datei unter einem neuen Namen zu speichern. Das Ergebnis war also genau so, als hätte es nur die JSON kopiert. Ich habe das Skript jetzt korrigiert und deutlich robuster gemacht. Die wichtigsten Verbesserungen: Robustere Datenrettung: Die Funktion extract_entries_from_html hat jetzt ein Fallback-Muster . Wenn das erste, sehr spezifische Muster fehlschlägt, versucht es ein allgemeineres. Das erhöht die Chance, die Daten erfolgreich zu extrahieren, auch wenn sich das Format der Export-Datei leicht ändert. Klareres Feedback: Ich habe viel aussagekräftigere print -Ausgaben hinzugefügt. Das Skript sagt dir jetzt genau, ob es die Muster anwenden konnte, wie viele Einträge es gefunden hat und warnt dich, falls die Extraktion fehlschlägt. So siehst du sofort, was passiert. Sauberere Daten: Die Bereinigung der extrahierten Texte wurde verbessert, um überflüssige Leerzeichen und Zeilenumbrüche zu entfernen. Hier ist der korrigierte und verbesserte Code, der deine Beobachtung berücksichtigt und das Problem behebt: import json import os import re from datetime import datetime from collections import defaultdict import copy # Import für die Erstellung einer Kopie der Originaldaten # ########################################################################## # 1. HILFSFUNKTIONEN ZUR ZEITSTEMPEL-EXTRAKTION (INTELLIGENTE LOGIK) # ########################################################################## def try_parse_timestamp(ts): """ Versucht, einen Zeitstempel in viele Formate zu parsen und gibt ein datetime-Objekt zurück. """ if not isinstance(ts, str) or not ts.strip(): return None ts = ts.strip().replace('MESZ', '').replace('MEZ', '').replace('UTC', '').strip() fmts = [ '%d.%m.%Y, %H:%M:%S', '%d.%m.%Y, %H:%M', '%Y-%m-%d, %H:%M:%S', '%Y-%m-%d, %H:%M', '%d/%m/%Y, %H:%M:%S', '%d/%m/%Y, %H:%M', '%d.%m.%Y %H:%M:%S', '%d.%m.%Y %H:%M', '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M', '%d.%m.%Y, %H:%M:%S.%f', ] for fmt in fmts: try: return datetime.strptime(ts, fmt) except Exception: continue date_parts = re.findall(r'(\d{1,4}[./-]\d{1,2}[./-]\d{2,4})', ts) if date_parts: for part in date_parts: for fmt in ['%d.%m.%Y', '%Y-%m-%d', '%d/%m/%Y', '%Y/%m/%d']: try: return datetime.strptime(part, fmt) except Exception: continue return None def extract_any_timestamp(entry): """ Sucht nach einem Zeitstempel in allen relevanten Feldern eines Eintrags. """ if not isinstance(entry, dict): return None, None candidates = [str(entry.get(key, '')) for key in ['timestamp', 'message', 'content', 'text']] ts_regex = re.compile(r'(\d{2}\.\d{2}\.\d{4}, \d{2}:\d{2}:\d{2}(?: [A-Z]+)?)') for c in candidates: m = ts_regex.search(c) if m: dt = try_parse_timestamp(m.group(1)) if dt: return dt, m.group(1) for c in candidates: dt = try_parse_timestamp(c) if dt: return dt, c return None, None def is_bedeutungslos(text): """Prüft, ob ein Text bedeutungslos ist.""" return not text or not text.strip() or bool(re.fullmatch(r'[\s\W_]+', text)) # ########################################################################## # 2. HTML-PARSING & DATENRETTUNG (JETZT ROBUSTER) # ########################################################################## def extract_entries_from_html(html_path): """ Extrahiert Prompt/Antwort-Paare und Zeitstempel aus dem Google 'Meine Aktivitäten'-HTML-Export. Diese Version ist robuster gegenüber kleinen Änderungen im HTML-Format. """ entries = [] try: with open(html_path, 'r', encoding='utf-8') as f: content = f.read() except Exception as e: print(f"[FEHLER] Konnte Quelldatei nicht lesen: {html_path} - {e}") return [] # VERSUCH 1: Präzises Muster, das die gesamte Zelle erfasst chat_block_regex_v1 = re.compile( r'<div class="outer-cell[^>]*>.*?