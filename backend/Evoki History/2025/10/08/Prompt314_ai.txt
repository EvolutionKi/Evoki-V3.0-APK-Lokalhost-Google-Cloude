Timestamp: 08.10.2025, 17:49:48 MESZ
Speaker: ai

Klar, hier ist der vollständige und korrigierte Code. Die beiden besprochenen Fehler wurden behoben: Der SyntaxError ( z'timestamp' ) wurde korrigiert. Der überflüssige, doppelte Code-Block am Ende der extract_any_timestamp -Funktion wurde entfernt. import json import os import re from datetime import datetime def try_parse_timestamp(ts): """ Versucht, einen Zeitstempel in verschiedene Formate zu parsen und gibt ein datetime-Objekt zurück. Gibt None zurück, wenn alles fehlschlägt. """ if not isinstance(ts, str) or not ts.strip(): return None ts = ts.strip() # Entferne Zeitzonen-Infos ts = ts.replace('MESZ', '').replace('MEZ', '').replace('UTC', '').strip() # Versuche Standardformat fmts = [ '%d.%m.%Y, %H:%M:%S', '%d.%m.%Y, %H:%M', '%Y-%m-%d, %H:%M:%S', '%Y-%m-%d, %H:%M', '%d/%m/%Y, %H:%M:%S', '%d/%m/%Y, %H:%M', '%Y/%m/%d, %H:%M:%S', '%Y/%m/%d, %H:%M', '%d.%m.%Y %H:%M:%S', '%d.%m.%Y %H:%M', '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M', '%d/%m/%Y %H:%M:%S', '%d/%m/%Y %H:%M', '%Y/%m/%d %H:%M:%S', '%Y/%m/%d %H:%M', ] for fmt in fmts: try: return datetime.strptime(ts, fmt) except Exception: continue # Versuche, nur das Datum zu parsen date_parts = re.findall(r'(\d{1,4}[./-]\d{1,2}[./-]\d{2,4})', ts) if date_parts: for part in date_parts: for fmt in ['%d.%m.%Y', '%Y-%m-%d', '%d/%m/%Y', '%Y/%m/%d']: try: return datetime.strptime(part, fmt) except Exception: continue return None def extract_any_timestamp(entry): """ Versucht, einen Zeitstempel aus beliebigen Feldern (timestamp, message, etc.) zu extrahieren und zu normalisieren. Gibt (datetime-Objekt, Zeitstempel-String) zurück oder (None, None) falls nicht gefunden. """ candidates = [] # Prüfe bekannte Felder for key in ['timestamp', 'message', 'content', 'text']: val = entry.get(key, '') if isinstance(val, str) and val.strip(): candidates.append(val.strip()) # Suche nach Zeitstempel-Muster in allen Feldern for val in entry.values(): if isinstance(val, str): candidates.append(val.strip()) # Regex für Zeitstempel ts_regex = re.compile(r'(\d{2}\.\d{2}\.\d{4}, \d{2}:\d{2}:\d{2}(?: [A-Z]+)?)') for c in candidates: m = ts_regex.search(c) if m: ts_str = m.group(1) dt = try_parse_timestamp(ts_str) if dt: return dt, ts_str # Fallback: versuche alle Strings als Zeitstempel zu parsen for c in candidates: dt = try_parse_timestamp(c) if dt: return dt, c return None, None def export_chats_to_folders(master_json_path, export_base_dir): """ Exportiert alle Chat-Einträge aus der Master-JSON in eine Ordnerstruktur Jahr/Monat/Tag/PromptX.txt Unsortierte werden nach Fehlerursache in Unterordnern abgelegt. Versucht, Zeitstempel automatisch zu erkennen und zu normalisieren. """ # Zusätzliche zentrale Gesamtliste für ALLE Nachrichten alle_nachrichten = [] alle_nachrichten_mit_zeit = [] with open(master_json_path, 'r', encoding='utf-8') as f: data = json.load(f) chat_data = data.get('gesamter_chatverlauf', {}) prompt_counter = {} unsortiert_counter = { 'Fehlender_Zeitstempel': 1, 'Falsches_Format': 1, 'Nicht_String': 1, 'Sonstige_Fehler': 1 } entries_2025 = [] entries_unsortiert = [] entries_bedeutungslos = [] alle_exportierten_texte = [] alle_exportierten_worte = 0 bedeutungslos_worte = 0 ursprungs_worte = 0 def is_bedeutungslos(text): # Nur Leerzeichen oder nur Satzzeichen if not text or not text.strip(): return True if re.fullmatch(r'[\s\W_]+', text): return True return False # Zähle alle Worte im Ursprungs-JSON (roh, alle Nachrichtenfelder) for day, entries in chat_data.items(): if not isinstance(entries, list): continue for entry in entries: msg = entry.get('message', '') ursprungs_worte += len(re.findall(r'\w+', msg)) for day, entries in chat_data.items(): if not isinstance(entries, list): continue try: date_obj = datetime.strptime(day, '%Y-%m-%d') year = str(date_obj.year) month = f"{date_obj.month:02d}" day_str = f"{date_obj.day:02d}" folder = os.path.join(export_base_dir, year, month, day_str) os.makedirs(folder, exist_ok=True) prompt_counter[day] = 1 for entry in entries: alle_nachrichten.append(dict(entry)) # Heuristik: Zeitstempel aus beliebigem Feld extrahieren dt, ts_str = extract_any_timestamp(entry) # Für spätere Sortierung merken entry_with_time = dict(entry) entry_with_time['__parsed_datetime'] = dt entry_with_time['__parsed_timestamp'] = ts_str alle_nachrichten_mit_zeit.append(entry_with_time) speaker = entry.get('speaker', 'unknown') message = entry.get('message', '') if is_bedeutungslos(message): entries_bedeutungslos.append(entry) bedeutungslos_worte += len(re.findall(r'\w+', message)) continue if dt: fname = f"Prompt{prompt_counter[day]}_{speaker}.txt" prompt_counter[day] += 1 file_path = os.path.join(folder, fname) with open(file_path, 'w', encoding='utf-8') as out: out.write(f"Timestamp: {ts_str}\nSpeaker: {speaker}\n\n{message}") alle_exportierten_texte.append(message) alle_exportierten_worte += len(re.findall(r'\w+', message)) if year == '2025': entries_2025.append({"timestamp": ts_str, "speaker": speaker, "message": message}) else: # Fallback: wie bisher timestamp = entry.get('timestamp', 'no-timestamp') if timestamp is None or (isinstance(timestamp, str) and timestamp.strip() == ''): group = 'Fehlender_Zeitstempel' elif not isinstance(timestamp, str): group = 'Nicht_String' else: group = 'Falsches_Format' group_folder = os.path.join(export_base_dir, 'Unsortiert', group) os.makedirs(group_folder, exist_ok=True) fname = f"Prompt{unsortiert_counter[group]}_{speaker}.txt" unsortiert_counter[group] += 1 file_path = os.path.join(group_folder, fname) with open(file_path, 'w', encoding='utf-8') as out: out.write(f"Timestamp: {timestamp}\nSpeaker: {speaker}\n\n{message}") alle_exportierten_texte.append(message) alle_exportierten_worte += len(re.findall(r'\w+', message)) entry_copy = dict(entry) if isinstance(entry, dict) else {} entry_copy['gruppe'] = group entries_unsortiert.append(entry_copy) except Exception: for entry in entries: alle_nachrichten.append(dict(entry)) dt, ts_str = extract_any_timestamp(entry) entry_with_time = dict(entry) entry_with_time['__parsed_datetime'] = dt entry_with_time['__parsed_timestamp'] = ts_str alle_nachrichten_mit_zeit.append(entry_with_time) speaker = entry.get('speaker', 'unknown') message = entry.get('message', '') if is_bedeutungslos(message): entries_bedeutungslos.append(entry) bedeutungslos_worte += len(re.findall(r'\w+', message)) continue if dt: year = str(dt.year) month = f"{dt.month:02d}" day_str = f"{dt.day:02d}" folder = os.path.join(export_base_dir, year, month, day_str) os.makedirs(folder, exist_ok=True) day_key = f"{year}-{month}-{day_str}" if day_key not in prompt_counter: prompt_counter[day_key] = 1 fname = f"Prompt{prompt_counter[day_key]}_{speaker}.txt" prompt_counter[day_key] += 1 file_path = os.path.join(folder, fname) with open(file_path, 'w', encoding='utf-8') as out: out.write(f"Timestamp: {ts_str}\nSpeaker: {speaker}\n\n{message}") alle_exportierten_texte.append(message) alle_exportierten_worte += len(re.findall(r'\w+', message)) if year == '2025': entries_2025.append({"timestamp": ts_str, "speaker": speaker, "message": message}) else: timestamp = entry.get('timestamp', None) if timestamp is None or (isinstance(timestamp, str) and (not timestamp.strip())): group = 'Fehlender_Zeitstempel' elif not isinstance(timestamp, str): group = 'Nicht_String' else: group = 'Falsches_Format' group_folder = os.path.join(export_base_dir, 'Unsortiert', group) os.makedirs(group_folder, exist_ok=True) fname = f"Prompt{unsortiert_counter[group]}_{speaker}.txt" unsortiert_counter[group] += 1 file_path = os.path.join(group_folder, fname) with open(file_path, 'w', encoding='utf-8') as out: out.write(f"Timestamp: {timestamp}\nSpeaker: {speaker}\n\n{message}") alle_exportierten_texte.append(message) alle_exportierten_worte += len(re.findall(r'\w+', message)) entry_copy = dict(entry) if isinstance(entry, dict) else {} entry_copy['gruppe'] = group entries_unsortiert.append(entry_copy) # Sortiere alle Nachrichten mit erkanntem Zeitstempel alle_nachrichten_mit_zeit_sorted = sorted( [e for e in alle_nachrichten_mit_zeit if e['__parsed_datetime'] is not None], key=lambda e: e['__parsed_datetime'] ) # Konvertiere datetime-Objekte zu Strings für JSON def convert_datetimes(obj): if isinstance(obj, dict): return {k: (v.isoformat() if isinstance(v, datetime) else v) for k, v in obj.items()} return obj alle_nachrichten_mit_zeit_sorted_serializable = [convert_datetimes(e) for e in alle_nachrichten_mit_zeit_sorted] # Schreibe sortierte Gesamtliste (verlustfrei, nach Zeit) all_json_sorted = os.path.join(export_base_dir, 'ALLE_NACHRICHTEN_SORTIERT.json') with open(all_json_sorted, 'w', encoding='utf-8') as f: json.dump(alle_nachrichten_mit_zeit_sorted_serializable, f, indent=2, ensure_ascii=False) # Schreibe zentrale Gesamtliste aller Nachrichten (verlustfrei) all_json = os.path.join(export_base_dir, 'ALLE_NACHRICHTEN.json') with open(all_json, 'w', encoding='utf-8') as f: json.dump(alle_nachrichten, f, indent=2, ensure_ascii=False) # Schreibe Zusammenfassungsdateien für 2025 (chronologisch sortiert nach heuristischem Zeitstempel) folder_2025 = os.path.join(export_base_dir, '2025') if entries_2025 and os.path.exists(folder_2025): # Sortiere nach heuristischem Zeitstempel def get_dt(e): # Nutze die gleiche Heuristik wie im Hauptcode dt = try_parse_timestamp(e.get('timestamp','')) if not dt: # Fallback: versuche aus message dt2, _ = extract_any_timestamp(e) return dt2 return dt entries_2025_sorted = sorted( [e for e in entries_2025 if e.get('timestamp')], key=lambda e: (get_dt(e) if get_dt(e) else datetime.max) ) with open(os.path.join(folder_2025, '2025_gesamt.txt'), 'w', encoding='utf-8') as f: for e in entries_2025_sorted: f.write(f"Timestamp: {e['timestamp']}\nSpeaker: {e['speaker']}\n{e['message']}\n---\n") with open(os.path.join(folder_2025, '2025_gesamt.json'), 'w', encoding='utf-8') as f: json.dump(entries_2025_sorted, f, indent=2, ensure_ascii=False) # Schreibe Zusammenfassungsdateien für Unsortiert folder_unsortiert = os.path.join(export_base_dir, 'Unsortiert') if entries_unsortiert and os.path.exists(folder_unsortiert): with open(os.path.join(folder_unsortiert, 'Unsortiert_gesamt.txt'), 'w', encoding='utf-8') as f: for e in entries_unsortiert: f.write(f"Gruppe: {e['gruppe']}\nTimestamp: {e['timestamp']}\nSpeaker: {e['speaker']}\n{e['message']}\n---\n") with open(os.path.join(folder_unsortiert, 'Unsortiert_gesamt.json'), 'w', encoding='utf-8') as f: json.dump(entries_unsortiert, f, indent=2, ensure_ascii=False) # Schreibe bedeutungslose Prompts in eigene Datei bedeutungslos_txt = os.path.join(export_base_dir, 'Bedeutungslose_Prompts.txt') bedeutungslos_json = os.path.join(export_base_dir, 'Bedeutungslose_Prompts.json') if entries_bedeutungslos: with open(bedeutungslos_txt, 'w', encoding='utf-8') as f: for e in entries_bedeutungslos: f.write(json.dumps(e, ensure_ascii=False) + '\n') with open(bedeutungslos_json, 'w', encoding='utf-8') as f: json.dump(entries_bedeutungslos, f, indent=2, ensure_ascii=False) # Verifizierungsdatei: Wortanzahl vergleichen verif_txt = os.path.join(export_base_dir, 'Verifizierung_Wortanzahl.txt') summe_export = alle_exportierten_worte + bedeutungslos_worte ratio = ursprungs_worte / summe_export if summe_export else 0 with open(verif_txt, 'w', encoding='utf-8') as f: f.write(f"Wörter Ursprungsdaten: {ursprungs_worte}\n") f.write(f"Wörter exportiert (alle): {alle_exportierten_worte}\n") f.write(f"Wörter bedeutungslose Prompts: {bedeutungslos_worte}\n") f.write(f"Summe exportiert: {summe_export}\n") f.write(f"Verhältnis Ursprungs/Export: {ratio:.5f}\n") if abs(1.0 - ratio) > 0.0001: f.write(f"[WARNUNG] Wortverlust oder -gewinn: {100 * abs(1.0 - ratio):.2f}%\n") else: f.write("[OK] Lückenlose Extraktion!\n") print(f"[ERFOLG] Export abgeschlossen. Basisordner: {export_base_dir}") def get_next_export_dir(script_dir, script_name): base_export_dir = os.path.join(script_dir, f"{script_name}_export") export_dir = base_export_dir idx = 1 while os.path.exists(export_dir): export_dir = f"{base_export_dir}_{idx}" idx += 1 return export_dir if __name__ == "__main__": # Passe die Pfade ggf. an script_dir = os.path.dirname(os.path.abspath(__file__)) master_json = os.path.join(script_dir, 'Master_Chronik_V10_FINAL.json') # Erzeuge einen fortlaufenden Export-Ordner oder benenne nach Skriptname script_name = os.path.splitext(os.path.basename(__file__))[0] export_dir = get_next_export_dir(script_dir, script_name) export_chats_to_folders(master_json, export_dir)