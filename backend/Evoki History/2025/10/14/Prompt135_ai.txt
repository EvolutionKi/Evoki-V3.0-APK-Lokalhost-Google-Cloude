Timestamp: 14.10.2025, 21:06:04 MESZ
Speaker: ai

Absolut! Ich verstehe, du möchtest, dass der Code zuverlässig auf deinem Smartphone läuft. Der bisherige Fehler lag an einem kleinen Tippfehler und daran, dass auf dem Handy die notwendigen Code-Bibliotheken oft manuell installiert werden müssen. Ich habe den Code nun so angepasst, dass er speziell für die Ausführung auf einem Smartphone in einer App wie Pydroid 3 optimiert ist. Was wurde für das Smartphone angepasst? Fehlerkorrektur: Der SyntaxError (das z'timestamp' ) ist selbstverständlich behoben. Einfache Dateipfade: Der Code sucht jetzt nicht mehr in komplizierten Verzeichnissen. Er geht davon aus, dass sich alle drei Dateien ( .py , .json , .txt ) im selben Ordner befinden. Das ist auf dem Handy am einfachsten und vermeidet Fehler. Klare Dateinamen: Der Code verwendet jetzt exakt die von dir genannten Dateinamen: Fallstudie Evoki.json und meineAktivitäten.txt . Besseres Feedback: Du bekommst jetzt mehr print -Ausgaben im Terminal, damit du genau siehst, was das Skript gerade tut. Finales Skript für dein Smartphone Erstelle eine neue Datei in Pydroid 3 und kopiere den gesamten folgenden Code hinein. Speichere sie als upload_wissen.py . import os import json import re from datetime import datetime # --- Wichtiger Hinweis --- # Stelle sicher, dass du die benötigten Bibliotheken über die Pip-Funktion # in Pydroid 3 installiert hast: # 1. astrapy # 2. sentence-transformers # 3. torch # 4. torchvision # 5. torchaudio try: from astrapy.db import AstraDB from sentence_transformers import SentenceTransformer except ImportError: print("### FEHLER: Wichtige Bibliotheken fehlen! ###") print("Bitte öffne das Menü in Pydroid, gehe zu 'Pip' und installiere:") print("- astrapy") print("- sentence-transformers") exit() # -- Konfiguration -- # 1. Trage hier deinen AstraDB API Endpoint ein ASTRA_DB_API_ENDPOINT = "DEIN_API_ENDPOINT" # z.B. "https-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx-us-east-1.apps.astra.datastax.com" # Dein Token ist hier bereits fest eingetragen ASTRA_DB_APPLICATION_TOKEN = "AstraCS:iYkZWofQBSwvrsaZDfLOIPZF:767785501650518af9bc18d0852ef134c3ee55c38ff898df6d33521df94f5e58" # 2. Dateinamen deiner Originaldateien (müssen im selben Ordner wie dieses Skript liegen) JSON_DATEI_PFAD = "Fallstudie Evoki.json" TEXT_DATEI_PFAD = "meineAktivitäten.txt" # 3. Definiere den Namen für die Collection (Tabelle) in AstraDB COLLECTION_NAME = "evoki_wissensbasis_smart" # -- Initialisierung des Embedding-Modells -- print("1. Lade das Embedding-Modell ('all-MiniLM-L6-v2')...") try: embedding_model = SentenceTransformer('all-MiniLM-L6-v2') VECTOR_DIMENSION = 384 print("-> Modell erfolgreich geladen.\n") except Exception as e: print(f"FEHLER beim Laden des Embedding-Modells: {e}") exit() def verarbeite_json_fallstudie(filepath: str) -> list: """Parst die 'Fallstudie Evoki.json' und extrahiert relevante Text-Abschnitte.""" print(f"2. Verarbeite JSON-Datei: {filepath}...") chunks = [] try: with open(filepath, 'r', encoding='utf-8') as f: data = json.load(f) # Extrahiere Chatverlauf chat_data = data.get("gesamter_chatverlauf_vektor", {}) for year, months in chat_data.items(): for month, days in months.items(): for day, interactions in days.items(): if isinstance(interactions, list): for interaction in interactions: msg = interaction.get("message", "").strip() if msg: speaker = interaction.get("speaker", "unbekannt") chunks.append({"text": f"Chat vom {day}.{month}.{year} ({speaker}): {msg}", "source": "Fallstudie_Chat"}) print(f"-> {len(chunks)} Chat-Abschnitte aus JSON extrahiert.") return chunks except FileNotFoundError: print(f"--> FEHLER: Die Datei '{filepath}' wurde nicht gefunden!") return [] except Exception as e: print(f"--> FEHLER beim Verarbeiten der JSON-Datei: {e}") return [] def verarbeite_html_aktivitaeten(filepath: str) -> list: """Liest die 'meineAktivitäten.txt' und extrahiert User-Prompts und AI-Antworten.""" print(f"3. Verarbeite Text-Datei (HTML): {filepath}...") chunks = [] try: with open(filepath, 'r', encoding='utf-8') as f: content = f.read() # Regex, um die Inhaltsblöcke zu finden blocks = re.findall(r'