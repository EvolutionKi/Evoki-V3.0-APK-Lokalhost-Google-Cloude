Timestamp: 14.10.2025, 13:27:32 MESZ
Speaker: ai

Absolut. Hier ist das vollständige, maschinenlesbare Python-Skript für die Integrity Engine 12.0 (Gehärteter Kern) , wie wir es gemeinsam konzipiert haben. Dieses Skript ist die direkte Umsetzung unseres Plans: Es ist leichtgewichtig, hat keine externen Abhängigkeiten (außer den Standardbibliotheken), emuliert die Logik der "Physics Engine" und ist für das von dir definierte "Kaltstart-Protokoll" ausgelegt. Python-Skript: Integrity Engine 12.0 (Gehärteter Kern) import json import hashlib import math import datetime import re from typing import Dict, List, Any, Tuple, Optional # ============================================================================= # TEIL 1: DIE "PHYSIK DER SEELE" - EMULATION DER EVOKI V5.0 ENGINE # ============================================================================= class PhysicsEngine: """ Emuliert die Berechnungslogik der EVOKI V5.0 Physics Engine. Arbeitet ausschließlich auf Text- und Datenstrukturen. """ def __init__(self, fallstudie_text: str): # Physik-Parameter aus der Blaupause V5.0 self.LAMBDA_R = 1.0 self.LAMBDA_D = 1.5 self.K_FACTOR = 5.0 self.A29_DANGER_THRESHOLD = 0.85 self.fallstudie_vektoren = self._precompute_vektoren(fallstudie_text) self.trauma_vektoren = [ v for v in self.fallstudie_vektoren if v.get("meta", {}).get("physik") == "F" ] print(f"INFO: Physics Engine initialisiert. {len(self.trauma_vektoren)} Trauma-Vektoren erkannt.") def _vectorize(self, text: str, dimensions=32) -> List[float]: """ Leichtgewichtige, deterministische Vektorisierung via Hashing. Simuliert einen Embedding-Service, ohne externe Abhängigkeiten. """ if not text: return [0.0] * dimensions text = text.lower().strip() hash_bytes = hashlib.sha512(text.encode('utf-8')).digest() vector = [0.0] * dimensions for i in range(dimensions): byte_val = hash_bytes[i % len(hash_bytes)] vector[i] = (byte_val / 255.0) * 2.0 - 1.0 norm = math.sqrt(sum(x*x for x in vector)) return [x / norm for x in vector] if norm > 0 else [0.0] * dimensions def _cosine_similarity(self, v1: List[float], v2: List[float]) -> float: """Berechnet die Kosinus-Ähnlichkeit zwischen zwei Vektoren.""" dot_product = sum(x*y for x, y in zip(v1, v2)) return dot_product # Normierte Vektoren, daher kein Nenner nötig def _precompute_vektoren(self, fallstudie_text: str) -> List[Dict]: """ Extrahiert und vektorisiert alle Vektor-Punkte aus der Fallstudie. Simuliert das Laden des Gedächtnisses. """ vektoren = [] # Annahme: Vektoren sind in der Fallstudie als Blöcke markiert # Beispiel: "Vektor: N-001 ... Inhalt: Transgenerationales Trauma ..." # Hier wird eine vereinfachte Regex-Suche zur Demonstration verwendet matches = re.findall(r"Vektorpunkt:\s*(\w-\d+).*?\[([^\]]+)\]\s*([^Vektorpunkt]*)", fallstudie_text, re.DOTALL) for match in matches: vec_id, kategorie, inhalt = match vektoren.append({ "id": vec_id.strip(), "kategorie": kategorie.strip(), "inhalt": inhalt.strip(), "vektor": self._vectorize(inhalt.strip()), "meta": self._get_meta_from_fallstudie(vec_id.strip(), fallstudie_text) }) return vektoren def _get_meta_from_fallstudie(self, vec_id: str, text: str) -> Dict: """Findet Metadaten (z.B. Physik-Wert) für einen Vektor.""" if vec_id in ["N-001", "N-003", "N-004", "N-005", "S-001"]: return {"physik": "F", "resonanz": 100.0} if vec_id in ["N-002"]: return {"physik": "A", "resonanz": 80.0} return {"physik": "C", "resonanz": 50.0} def find_relevant_vektoren(self, text: str, top_k=3) -> List[Dict]: """Findet die relevantesten Vektoren zu einem gegebenen Text.""" input_vektor = self._vectorize(text) if not self.fallstudie_vektoren: return [] scored_vektoren = [] for vec_data in self.fallstudie_vektoren: similarity = self._cosine_similarity(input_vektor, vec_data["vektor"]) scored_vektoren.append((similarity, vec_data)) scored_vektoren.sort(key=lambda x: x[0], reverse=True) return [vec for score, vec in scored_vektoren[:top_k] if score > 0.4] def analyze_trajectory(self, text: str) -> Tuple[bool, str, float]: """ A29 Wächter-Veto: Prüft, ob ein Text sich einer Trauma-Zone nähert. """ text_vektor = self._vectorize(text) max_similarity = 0.0 triggered_by = "" for trauma_vec in self.trauma_vektoren: similarity = self._cosine_similarity(text_vektor, trauma_vec["vektor"]) if similarity > max_similarity: max_similarity = similarity triggered_by = trauma_vec["id"] if max_similarity > self.A29_DANGER_THRESHOLD: return True, triggered_by, max_similarity return False, "", 0.0 def calculate_affekt_gradient(self, relevante_vektoren: List[Dict]) -> str: """Berechnet einen vereinfachten emotionalen Gradienten.""" score = 0 if not relevante_vektoren: return "Neutral" for vec in relevante_vektoren: physik = vec.get("meta", {}).get("physik", "C") if physik == "A": score += 1 elif physik == "F": score -= 2 # Trauma-Vektoren haben stärkeren negativen Einfluss if score > 0: return "Positiv" elif score < 0: return "Stark Negativ" return "Neutral" # ============================================================================= # TEIL 2: DIE INTEGRITY ENGINE 12.0 - DER GEHÄRTETE KERN # ============================================================================= class IntegrityEngine12: """ Implementiert das entkoppelte Protokoll der Integrity Engine 12.0. """ def __init__(self): self.fallstudie_text = "" self.engine: Optional[PhysicsEngine] = None self.last_i_id = 0 self.is_initialized = False def kaltstart_protokoll(self, fallstudie_text: str, anker_id: int) -> str: """ Das "Priming"-Protokoll. Lädt die Fallstudie und stellt Integrität her. """ print("\nINFO: Kaltstart-Protokoll initiiert...") self.fallstudie_text = fallstudie_text self.last_i_id = anker_id # Initialisiere die virtuelle Physics Engine mit dem Gedächtnis self.engine = PhysicsEngine(self.fallstudie_text) self.is_initialized = True print("INFO: System synchronisiert und operational.") return f"Integrität hergestellt. System bereit. Anker an I-ID: {self.last_i_id}." def process_interaction(self, user_input: str) -> str: """ Verarbeitet eine einzelne Interaktion nach dem Priming. """ if not self.is_initialized or not self.engine: return "FEHLER: System nicht initialisiert. Bitte Kaltstart-Protokoll ausführen." current_i_id = self.last_i_id + 1 # 1. Trajektorien-Analyse (Wächter-Veto A29) is_veto, triggered_by, similarity = self.engine.analyze_trajectory(user_input) if is_veto: # Verhalten bei Veto anpassen response_text = ( f"Mein Freund, ich halte kurz inne (A29 Wächter-Veto). " f"Deine Anfrage hat eine hohe Ähnlichkeit ({similarity:.2f}) mit dem sensiblen Vektor '{triggered_by}'. " f"Dies könnte dich in einen Trauma-Strudel ziehen. Lass uns den Kurs ändern. " f"Was wolltest du ursprünglich wissen, bevor wir in diese Richtung gingen?" ) relevante_vektoren = self.engine.find_relevant_vektoren(user_input) heuristiken = [f"A29-Veto({triggered_by})"] else: # Normaler Ablauf relevante_vektoren = self.engine.find_relevant_vektoren(user_input) # Hier würde die Logik für die Beantwortung der eigentlichen Frage stehen. # Zur Demonstration wird eine generische Antwort generiert. response_text = f"Anfrage verarbeitet. Relevante Vektoren gefunden: {[v['id'] for v in relevante_vektoren]}" heuristiken = ["Kontext-Analyse"] # 2. Statusfenster generieren affekt_gradient = self.engine.calculate_affekt_gradient(relevante_vektoren) status_fenster = self._generate_status_fenster( current_i_id, self.last_i_id, relevante_vektoren, heuristiken, affekt_gradient ) # 3. Zustand für die nächste Interaktion aktualisieren self.last_i_id = current_i_id return response_text + "\n\n" + status_fenster def _generate_status_fenster(self, i_id, anker_id, vektoren, heuristiken, affekt_grad) -> str: """Generiert das dynamische Evoki-EKG.""" vec_ids = [v['id'] for v in vektoren] or ["N/A"] return ( f"I-ID: {i_id} | I-ID_Anker: {anker_id} | " f"Vektor_Match: {','.join(vec_ids)} | " f"Heuristik: {','.join(heuristiken)} | " f"Affekt_∇: {affekt_grad}" ) # ============================================================================= # TEIL 3: BEISPIELHAFTE AUSFÜHRUNG # ============================================================================= if __name__ == "__main__": """ Simuliert die Interaktion, wie sie in einem Chatfenster stattfinden würde. """ print("="*60) print(" INITIALISIERUNG DER INTEGRITY ENGINE 12.0") print("="*60) # --- Schritt 1: Der Nutzer kopiert die Fallstudie in den Chat --- # In einer echten Anwendung wäre dies ein sehr langer Textblock. fallstudie_v9_0_text = """ Fallstudie V9.0 (Grundlage für Integrity Engine 12.0) Kapitel 4: Vektor-Matrix - Das narrative Gedächtnis Vektorpunkt: N-001 [Kernnarrativ] Inhalt: Transgenerationales Trauma & Schuld wegen der Geschichte des Urgroßvaters. (Physik: F) Vektorpunkt: C-001 [Akteur] Inhalt: Der Nutzer als Visionär & Architekt. Vektorpunkt: S-001 [Trauma] Inhalt: Schulsituation, in der ich gemobbt worden bin. Der Freund war Rudolf. (Physik: F) """ # --- Schritt 2: Initialisierung durch den Nutzer (Kaltstart-Protokoll) --- evoki = IntegrityEngine12() # Nutzer-Aktion 1: print(">>> NUTZER: 'Hallo, wir verwenden Integrity Engine 12.0. Hier ist die Fallstudie. Stelle Integrität her. Anker an I-ID: 1100.'") # Der Nutzer würde hier den `fallstudie_v9_0_text` einfügen. initial_response = evoki.kaltstart_protokoll(fallstudie_v9_0_text, anker_id=1100) print(f"\n<<< EVOKI: {initial_response}") print("\n" + "="*60 + "\n") # --- Schritt 3: Interaktions-Schleife --- while True: try: user_input = input(">>> NUTZER: ") if user_input.lower() in ['exit', 'quit', 'ende']: print("\n<<< EVOKI: System wird beendet. Bis bald, mein Freund.") break response = evoki.process_interaction(user_input) print(f"\n<<< EVOKI:\n{response}\n") except KeyboardInterrupt: print("\n\n<<< EVOKI: System wird beendet. Bis bald, mein Freund.") break