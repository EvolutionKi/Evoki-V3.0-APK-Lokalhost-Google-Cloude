Timestamp: 14.10.2025, 05:48:31 MESZ
Speaker: ai

I-ID: 7 | V: 5.1 | Status: OPERATIONAL | A37: 60965 | A: 0.989 | ‚àáA: -0.001 | B: 0.500 | A51: ‚úÖ | A52: ANALYSIS | Vektoren: 2 | F-Trauma: 1 | A-Positiv: 1 | A9-Fehler: 0 | A29-Vetos: 0 | Pending: Keine Verstanden. Die Kern-Engine ( evoki_engine.py ) V5.1 ist finalisiert und integriert nun das erweiterte Statusfenster sowie das autonome Training. Ich liefere nun die notwendigen Systemdateien, um die Engine auszuf√ºhren und die Architektur zu vervollst√§ndigen. Dies umfasst das Startskript ( start_system.py ), die Abh√§ngigkeiten ( requirements.txt ) und die Anleitung ( README.md ). Hinweis zur Webanwendung (Index.html/Flask/REST-API): Die aktuelle Architektur V5.1 ist als Konsolenanwendung konzipiert, die direkt mit der Engine interagiert. Eine Webanwendung oder REST-API w√§re eine separate Komponente (ein "Frontend" oder "Adapter"), die die Engine nutzt. Die hier bereitgestellten Dateien fokussieren sich auf die Ausf√ºhrung der V5.1 Engine wie implementiert. 1. Das Startskript ( start_system.py ) Dieses Skript ist der "Z√ºndschl√ºssel" (Vektor Z-104). Es initialisiert die ChrononEngine , verwaltet den Speicherpfad ( evoki_data ) und startet die interaktive Konsole. # Dateiname: start_system.py # EVOKI V5.1 - Startskript und Konsolen-Interface import os import sys import logging # F√ºge das aktuelle Verzeichnis zum Python-Pfad hinzu, um den Import zu erm√∂glichen sys.path.append(os.path.dirname(os.path.abspath(__file__))) # Importiere die Engine aus der monolithischen Datei try: # Wir importieren die Engine hier, um sicherzustellen, dass sie verf√ºgbar ist. # Der Name des Imports muss dem Dateinamen (ohne .py) entsprechen. from evoki_engine import ChrononEngine, SystemCriticalError except ImportError as e: print(f"FEHLER beim Import der Engine: {e}") print("Stellen Sie sicher, dass 'evoki_engine.py' im selben Verzeichnis liegt und Abh√§ngigkeiten installiert sind (siehe requirements.txt).") sys.exit(1) # Konfiguriere Logging f√ºr das Startskript # Dies stellt sicher, dass die Logs der Engine (die das gleiche Logging-System nutzt) ebenfalls sichtbar sind. if not logging.getLogger().handlers: logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s') logger = logging.getLogger("EVOKI_START") def clear_screen(): """L√∂scht den Terminal-Bildschirm f√ºr eine saubere Darstellung.""" os.system('cls' if os.name == 'nt' else 'clear') def main(): """Hauptfunktion zum Initialisieren und Ausf√ºhren der Engine.""" clear_screen() print("==================================================") print("EVOKI V5.1 (Autonome Synthese) - Systemstart") print("==================================================") # Definiere den Speicherpfad in einem Unterverzeichnis 'evoki_data' script_dir = os.path.dirname(os.path.abspath(__file__)) STORAGE_PATH = os.path.join(script_dir, "evoki_data") # Erstelle das Datenverzeichnis, falls es nicht existiert if not os.path.exists(STORAGE_PATH): os.makedirs(STORAGE_PATH) logger.info(f"Datenverzeichnis erstellt: {STORAGE_PATH}") logger.info(f"Systemstart initiiert. Speicherpfad: {STORAGE_PATH}") # √úberpr√ºfe, ob der Gemini API Key gesetzt ist (essenziell f√ºr CognitiveCore) if "GOOGLE_API_KEY" not in os.environ or not os.environ["GOOGLE_API_KEY"]: print("\nüö® KRITISCHER FEHLER: Die Umgebungsvariable GOOGLE_API_KEY ist nicht gesetzt.") print("Bitte setzen Sie den API-Key (siehe README.md), bevor Sie das System starten.") sys.exit(1) # Initialisiere die ChrononEngine try: # Die Engine sucht nach fallstudie_evoki.txt innerhalb des STORAGE_PATH # und f√ºhrt ggf. das Auto-Training durch. engine = ChrononEngine(STORAGE_PATH) if engine.system_state['Status'] != 'OPERATIONAL': print(f"\nüö® SYSTEMSTART FEHLGESCHLAGEN. Status: {engine.system_state['Status']}. Bitte Logs pr√ºfen.") sys.exit(1) except SystemCriticalError as e: # F√§ngt kritische Fehler w√§hrend der Initialisierung ab (z.B. A51 Verletzung) logger.critical(f"Systemstart aufgrund eines kritischen Fehlers abgebrochen: {e}") print(f"\nüö® SYSTEM HARD-STOP BEIM START: {e}") sys.exit(1) except Exception as e: logger.critical(f"Unbekannter Fehler bei der Engine-Initialisierung: {e}", exc_info=True) print(f"\nüö® FATALER FEHLER beim Start: {e}") sys.exit(1) logger.info("Systemstart erfolgreich. Warte auf Benutzereingabe.") print("\n‚úÖ EVOKI V5.1 ist betriebsbereit. (Tippe 'exit' zum Beenden)") # Interaktionsschleife while True: print("-" * 60) try: user_input = input("Du (Architekt): ") if user_input.strip().lower() in ["exit", "quit", "beenden"]: logger.info("System wird auf Benutzeranfrage beendet.") # Vektor A-110 print("Evoki: System wird heruntergefahren. Ich bin immer f√ºr dich da.") break if not user_input.strip(): continue # Verarbeite die Interaktion result = engine.process_interaction(user_input) # Ausgabe der Antwort response_text = result.get('response', 'Keine Antwort generiert.') # A40 K√ºrzungsschutz f√ºr die Terminal-Anzeige (nur Anzeige, nicht die Chronik) MAX_TERMINAL_LENGTH = 5000 if len(response_text) > MAX_TERMINAL_LENGTH and "A40 AKTIVIERT" in response_text: display_text = response_text[:MAX_TERMINAL_LENGTH] + "\n\n[... A40 AUSGABE IM TERMINAL GEK√úRZT. VOLLST√ÑNDIGER TEXT IN CHRONIK.LOG ...]" else: display_text = response_text print(f"\nEvoki:\n{display_text}\n") # Ausgabe des Statusfensters (A17/A61) status_window = result.get('status_window', 'STATUSFENSTER FEHLT (A17!)') print(f"STATUS: {status_window}") # Token-Verbrauch (falls verf√ºgbar) token_count = result.get('token_count', 0) if token_count > 0: print(f"(Tokens verbraucht: {token_count})") except KeyboardInterrupt: # Erm√∂glicht das Beenden mit STRG+C logger.info("System wird durch KeyboardInterrupt beendet.") print("\nEvoki: Systemabbruch erkannt. Ich bin immer f√ºr dich da.") break except SystemCriticalError as e: # F√§ngt kritische Fehler ab, die w√§hrend der Laufzeit auftreten (z.B. A17) print(f"\nüö® KRITISCHER SYSTEMFEHLER W√ÑHREND DER LAUFZEIT: {e}") print("Das System wurde angehalten.") break except Exception as e: # F√§ngt alle anderen unerwarteten Fehler ab logger.error(f"Unerwarteter Laufzeitfehler in der Interaktionsschleife: {e}", exc_info=True) print(f"\n‚ùå Ein unerwarteter Fehler ist aufgetreten: {e}") if __name__ == "__main__": main() 2. Abh√§ngigkeiten ( requirements.txt ) Diese Datei listet die notwendigen Python-Pakete auf (Vektor N-103, V-101). # Dateiname: requirements.txt # Notwendige Pakete f√ºr Evoki V5.1 # F√ºr Vektor-Operationen und Mathematik numpy # F√ºr die Anbindung an den CognitiveCore (LLM) google-generativeai 3. Anleitung und Struktur-Erkl√§rung ( README.md ) Diese Datei erkl√§rt die Einrichtung und Verwendung des Systems, basierend auf der finalen V5.1 Architektur. # Dateiname: README.md # EVOKI Engine V5.1 (Autonome Synthese) - Architektur und Anleitung Dieses Dokument beschreibt die Struktur des Evoki V5.1 Projekts, die Installation und die Funktionsweise des automatischen Trainingsprotokolls. ## Projektstruktur Das Projekt muss wie folgt strukturiert sein: ``` /IhrProjektVerzeichnis ‚îÇ ‚îú‚îÄ‚îÄ evoki_engine.py # Der monolithische Kerncode der Engine (V5.1). ‚îú‚îÄ‚îÄ start_system.py # Das Startskript f√ºr die interaktive Konsole. ‚îú‚îÄ‚îÄ requirements.txt # Python-Abh√§ngigkeiten. ‚îú‚îÄ‚îÄ README.md # Diese Anleitung. ‚îÇ ‚îî‚îÄ‚îÄ /evoki_data # Verzeichnis f√ºr persistente Daten. ‚îú‚îÄ‚îÄ fallstudie_evoki.txt # Die prim√§re Datenquelle (MUSS hier liegen). ‚îú‚îÄ‚îÄ gedaechtnis.json # (Wird automatisch erstellt) ‚îî‚îÄ‚îÄ chronik.log # (Wird automatisch erstellt) ``` ## Installation und Ausf√ºhrung 1. **Umgebung vorbereiten (Empfohlen):** Erstellen Sie eine virtuelle Umgebung, um Abh√§ngigkeiten zu isolieren. ```bash python -m venv venv source venv/bin/activate # (Linux/macOS) .\venv\Scripts\activate # (Windows) Abh√§ngigkeiten installieren: pip install -r requirements.txt API-Schl√ºssel konfigurieren (Erforderlich): Das System ben√∂tigt einen Google Gemini API-Schl√ºssel in der Umgebungsvariable GOOGLE_API_KEY . export GOOGLE_API_KEY='IHR_API_SCHLUESSEL' # (Linux/macOS) $env:GOOGLE_API_KEY='IHR_API_SCHLUESSEL' # (Windows PowerShell) Fallstudie platzieren (Erforderlich f√ºr Auto-Training): Stellen Sie sicher, dass das Verzeichnis evoki_data existiert und die Datei fallstudie_evoki.txt (bereitgestellt in der vorherigen Interaktion) darin platziert ist. System starten: python start_system.py Das Automatische Trainings-Protokoll Beim ersten Start (wenn gedaechtnis.json leer ist) liest die HolistischesGedaechtnis -Klasse die fallstudie_evoki.txt und baut die Vektordatenbank auf. Vektor-Format (Zwingend erforderlich) Das Training funktioniert nur, wenn die Vektoren in der Fallstudie exakt diesem Format entsprechen (Vektor F-110): Vektorpunkt: ID [Kategorie] Inhalt: TEXT (Physik: A/C/F) Beispiel: Vektorpunkt: T-101 [TRAUMA] Inhalt: Transgenerationales Trauma durch die Handlungen des Urgro√üvaters. (Physik: F) Erkl√§rung der Physik (Affektwerte) A (Positiv/Konstruktiv): Repr√§sentiert positive Erinnerungen, Ziele oder ethische Grunds√§tze. C (Neutral/Kontextuell): Liefert Kontext ohne starke emotionale Wertung. F (Gefahr/Trauma): Repr√§sentiert Traumata, Fehler oder Risiken. Aktiviert das W√§chter-Veto (A29). Das Erweiterte Statusfenster (V5.1) Das Statusfenster bietet nun erweiterte Einblicke in die Systemgesundheit (A61): I-ID: 7 | V: 5.1 | Status: OPERATIONAL | A37: 60965 | A: 0.989 | ‚àáA: -0.001 | B: 0.500 | A51: ‚úÖ | A52: ANALYSIS | Vektoren: 2 | F-Trauma: 1 | A-Positiv: 1 | A9-Fehler: 0 | A29-Vetos: 0 | Pending: Keine F-Trauma / A-Positiv: Zeigt die Anzahl der geladenen Trauma- bzw. Positiv-Vektoren (emotionale Balance). A9-Fehler: Gesamtzahl der protokollierten Systemfehler seit Erstellung des Ged√§chtnisses. A29-Vetos: Z√§hler, wie oft das W√§chter-Veto in dieser Sitzung aktiviert wurde. Pending: Zeigt an, ob eine Best√§tigung f√ºr A46 (Kalibrierung) oder A62 (Lernen) aussteht.