Timestamp: 14.10.2025, 20:56:16 MESZ
Speaker: ai

Hallo! Absolut. Ich habe beide Fehlermeldungen beachtet und den Code entsprechend angepasst. Du hattest zwei Probleme: ModuleNotFoundError : Dieser Fehler trat auf, weil die notwendigen Python-Bibliotheken ( astrapy , sentence-transformers ) noch nicht installiert waren. Das hast du anscheinend durch die Installation über Pip behoben. SyntaxError : Dieser zweite Fehler war ein einfacher Tippfehler direkt im Code. In Zeile 208 stand fälschlicherweise z'timestamp' , was Python nicht versteht. Ich habe diesen Tippfehler korrigiert und das Skript so überarbeitet, dass es beide deiner Dateien ( Fallstudie Evoki.json und meineAktivitäten.txt ) einliest, die Daten zusammenführt und dann chronologisch sortiert und exportiert. Finaler, korrigierter Code zum Sortieren beider Dateien Hier ist das vollständige, funktionierende Skript. Es ist speziell dafür ausgelegt, deine beiden Dateien zu verarbeiten. import json import os import re from datetime import datetime def versuche_zeitstempel_zu_parsen(ts): """ Versucht, einen Zeitstempel in verschiedenen Formaten zu parsen und gibt ein datetime-Objekt zurück. Gibt None zurück, wenn alle Versuche fehlschlagen. """ if not isinstance(ts, str) or not ts.strip(): return None ts = ts.strip().replace('MESZ', '').replace('MEZ', '').replace('UTC', '').strip() formate = [ '%d.%m.%Y, %H:%M:%S', '%d.%m.%Y, %H:%M', '%Y-%m-%d, %H:%M:%S', '%Y-%m-%d, %H:%M', '%d/%m/%Y, %H:%M:%S', '%d/%m/%Y, %H:%M', '%Y/%m/%d, %H:%M:%S', '%Y/%m/%d, %H:%M', '%d.%m.%Y %H:%M:%S', '%d.%m.%Y %H:%M', '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M', '%d/%m/%Y %H:%M:%S', '%d/%m/%Y %H:%M', '%Y/%m/%d %H:%M:%S', '%Y/%m/%d %H:%M', '%d.%m.%Y', '%Y-%m-%d', '%d/%m/%Y', '%Y/%m/%d' ] for fmt in formate: try: return datetime.strptime(ts, fmt) except ValueError: continue return None def extrahiere_beliebigen_zeitstempel(eintrag): """ Versucht, einen Zeitstempel aus beliebigen Feldern zu extrahieren. Gibt (datetime-Objekt, Zeitstempel-String) zurück oder (None, None). """ kandidaten = [] for schluessel in ['timestamp', 'message', 'content', 'text']: wert = eintrag.get(schluessel, '') if isinstance(wert, str): kandidaten.append(wert.strip()) for wert in eintrag.values(): if isinstance(wert, str): kandidaten.append(wert.strip()) ts_regex = re.compile(r'(\d{1,2}\.\d{1,2}\.\d{4}, \d{2}:\d{2}:\d{2})') for c in kandidaten: match = ts_regex.search(c) if match: ts_str = match.group(1) dt = versuche_zeitstempel_zu_parsen(ts_str) if dt: return dt, ts_str for c in kandidaten: dt = versuche_zeitstempel_zu_parsen(c) if dt: return dt, c return None, None def lade_chats_aus_fallstudie(json_pfad): """Lädt die Chat-Daten aus der 'Fallstudie Evoki.json'.""" print(f"Lade Daten aus: {json_pfad}") with open(json_pfad, 'r', encoding='utf-8') as f: data = json.load(f) chat_daten = data.get('gesamter_chatverlauf', {}) alle_eintraege = [] # Die Struktur ist { "YYYY": { "MM": { "DD": [...] } } } for monate in chat_daten.values(): for tage in monate.values(): for tages_eintraege in tage.values(): if isinstance(tages_eintraege, list): alle_eintraege.extend(tages_eintraege) print(f"-> {len(alle_eintraege)} Einträge aus Fallstudie geladen.") return alle_eintraege def lade_chats_aus_aktivitaeten(txt_pfad): """Lädt die Chat-Daten aus der 'meineAktivitäten.txt'.""" print(f"Lade Daten aus: {txt_pfad}") with open(txt_pfad, 'r', encoding='utf-8') as f: content = f.read() eintraege = [] # Regex, um die Blöcke mit "Eingegebener Prompt" zu finden bloecke = re.findall(r'<div class="content-cell mdl-cell.*?>(.*?)</div><div class="content-cell mdl-cell mdl-cell--12-col', content, re.DOTALL) for block in bloecke: prompt_match = re.search(r'