Timestamp: 14.10.2025, 03:52:53 MESZ
Speaker: ai

Of course. I'll outline how to adapt your web application to allow for both uploading and downloading a consolidated JSON file containing your case study and chronicle, ensuring the data is persistently stored. This process involves two key components: the frontend (the HTML your browser renders) and the backend (a Python script on your server that handles the logic). Frontend: The index.html File This is the user interface. It needs a form for uploading a file and a link or button for downloading the existing data. I'll add some basic styling to make it clear. Replace the content of your main HTML file with the following: <!DOCTYPE html> <html lang="de"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Evoki Datenmanagement</title> <style> body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; background-color: #f4f7f9; color: #333; max-width: 800px; margin: 40px auto; padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); } h1, h2 { color: #1a2533; border-bottom: 2px solid #e1e8ed; padding-bottom: 10px; } .container { background-color: #ffffff; padding: 25px; border-radius: 8px; margin-bottom: 20px; } .btn { display: inline-block; padding: 12px 20px; font-size: 16px; font-weight: bold; text-align: center; color: #fff; background-color: #007bff; border: none; border-radius: 5px; cursor: pointer; text-decoration: none; transition: background-color 0.3s; } .btn:hover { background-color: #0056b3; } input[type="file"] { border: 1px solid #ccc; padding: 10px; border-radius: 5px; width: calc(100% - 24px); } .download-link { font-size: 18px; } .status-message { margin-top: 15px; padding: 10px; border-radius: 5px; display: none; } .success { background-color: #d4edda; color: #155724; } .error { background-color: #f8d7da; color: #721c24; } </style> </head> <body> <h1>Evoki Datenmanagement</h1> <div class="container"> <h2>⬆️ Daten hochladen</h2> <p>Laden Sie hier eine <code>.json</code>-Datei hoch, die die Fallstudie und die Chronik enthält. Bestehende Daten werden überschrieben.</p> <form id="uploadForm" enctype="multipart/form-data"> <input type="file" name="file" id="fileInput" accept=".json" required> <br><br> <button type="submit" class="btn">Jetzt Hochladen</button> </form> <div id="uploadStatus" class="status-message"></div> </div> <div class="container"> <h2>⬇️ Daten herunterladen</h2> <p>Laden Sie die aktuell auf dem Server gespeicherten Daten (Fallstudie & Chronik) als <code>.json</code>-Datei herunter.</p> <a href="/download" class="btn download-link" id="downloadLink">Daten Herunterladen</a> </div> <script> const uploadForm = document.getElementById('uploadForm'); const fileInput = document.getElementById('fileInput'); const uploadStatus = document.getElementById('uploadStatus'); uploadForm.addEventListener('submit', async (event) => { event.preventDefault(); // Verhindert das Neuladen der Seite const formData = new FormData(); formData.append('file', fileInput.files[0]); uploadStatus.style.display = 'none'; // Status zurücksetzen try { const response = await fetch('/upload', { method: 'POST', body: formData, }); const result = await response.json(); if (response.ok) { uploadStatus.textContent = result.message; uploadStatus.className = 'status-message success'; } else { throw new Error(result.error || 'Ein unbekannter Fehler ist aufgetreten.'); } } catch (error) { uploadStatus.textContent = 'Fehler: ' + error.message; uploadStatus.className = 'status-message error'; } uploadStatus.style.display = 'block'; }); </script> </body> </html> Backend: Eine app.py für die Logik This Python script uses the Flask web framework to create a simple server. It defines three crucial endpoints: / (die Hauptseite): Serviert die oben erstellte index.html . /upload : Nimmt die hochgeladene JSON-Datei entgegen und speichert sie persistent auf dem Server. /download : Ermöglicht das Herunterladen der gespeicherten Datei. First, you need to install Flask: pip install Flask Now, create a file named app.py in the same directory as your index.html and add this code: import os from flask import Flask, request, jsonify, send_from_directory, render_template_string from werkzeug.utils import secure_filename # --- Konfiguration --- # Verzeichnis für den Festspeicher (persistent storage) # In einer echten Cloud-Anwendung wäre dies ein Pfad zu einem persistenten Volume, # z.B. /mnt/data oder ein Google Cloud Storage Bucket. STORAGE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "evoki_festspeicher") ALLOWED_EXTENSIONS = {'json'} PERSISTENT_FILENAME = "evoki_data.json" # Fester Dateiname für die Daten app = Flask(__name__) app.config['STORAGE_DIR'] = STORAGE_DIR # Stellt sicher, dass das Speicherverzeichnis existiert os.makedirs(app.config['STORAGE_DIR'], exist_ok=True) def allowed_file(filename): """Prüft, ob die Dateiendung erlaubt ist.""" return '.' in filename and \ filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS @app.route('/') def index(): """Zeigt die Hauptseite (index.html) an.""" try: with open("index.html", "r", encoding="utf-8") as f: html_content = f.read() return render_template_string(html_content) except FileNotFoundError: return "Fehler: index.html nicht gefunden.", 404 @app.route('/upload', methods=['POST']) def upload_file(): """Nimmt eine JSON-Datei entgegen und speichert sie persistent.""" if 'file' not in request.files: return jsonify(error="Kein Dateiteil im Request gefunden."), 400 file = request.files['file'] if file.filename == '': return jsonify(error="Keine Datei ausgewählt."), 400 if file and allowed_file(file.filename): # Wir verwenden einen festen, sicheren Dateinamen für die Speicherung filepath = os.path.join(app.config['STORAGE_DIR'], PERSISTENT_FILENAME) try: file.save(filepath) print(f"Datei erfolgreich gespeichert unter: {filepath}") return jsonify(message=f"Datei '{secure_filename(file.filename)}' erfolgreich hochgeladen und als '{PERSISTENT_FILENAME}' gespeichert."), 200 except Exception as e: print(f"Fehler beim Speichern der Datei: {e}") return jsonify(error="Ein interner Fehler ist beim Speichern der Datei aufgetreten."), 500 else: return jsonify(error="Ungültiger Dateityp. Bitte laden Sie eine .json-Datei hoch."), 400 @app.route('/download') def download_file(): """Stellt die gespeicherte JSON-Datei zum Download bereit.""" try: return send_from_directory( app.config['STORAGE_DIR'], PERSISTENT_FILENAME, as_attachment=True ) except FileNotFoundError: return "Fehler: Es wurden noch keine Daten hochgeladen.", 404 if __name__ == '__main__': # Startet den lokalen Testserver app.run(debug=True, port=5000) So funktioniert alles zusammen Starten: Führen Sie das app.py -Skript aus ( python app.py ). Ein lokaler Webserver startet. Aufrufen: Öffnen Sie Ihren Webbrowser und gehen Sie zu http://127.0.0.1:5000 . Sie sehen die HTML-Oberfläche. Hochladen: Sie wählen eine .json -Datei auf Ihrem Computer aus. Beim Klick auf "Jetzt Hochladen" sendet der JavaScript-Code im Hintergrund die Datei an den /upload -Endpunkt des Python-Servers. Der Server prüft die Datei, speichert sie im Ordner evoki_festspeicher unter dem festen Namen evoki_data.json und sendet eine Erfolgsmeldung zurück. Herunterladen: Wenn Sie auf den "Daten Herunterladen"-Button klicken, sendet der Browser eine Anfrage an den /download -Endpunkt. Der Python-Server sucht die evoki_data.json -Datei im Speicherverzeichnis und sendet sie an Ihren Browser zurück, der daraufhin den Download-Dialog startet. Persistenz: Da die Datei in einem Ordner auf dem Server gespeichert wird, bleiben die Daten auch nach einem Neustart des Python-Skripts erhalten. In einer echten Google Cloud-Umgebung würde dieser Ordner auf einem Persistent Disk Volume liegen, um die Daten auch bei einem Neustart des gesamten Containers zu bewahren.