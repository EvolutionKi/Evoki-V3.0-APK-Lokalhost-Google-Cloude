Timestamp: 14.10.2025, 20:50:08 MESZ
Speaker: ai

Absolut! Hier ist der vollständige und korrigierte Code mit allen Kommentaren, Funktionsbeschreibungen und Ausgaben auf Deutsch. Code zur chronologischen Sortierung und zum Export von Chat-Verläufen import json import os import re from datetime import datetime def versuche_zeitstempel_zu_parsen(ts): """ Versucht, einen Zeitstempel in verschiedenen Formaten zu parsen und gibt ein datetime-Objekt zurück. Gibt None zurück, wenn alle Versuche fehlschlagen. """ if not isinstance(ts, str) or not ts.strip(): return None ts = ts.strip() # Entferne Zeitzonen-Informationen, um das Parsen zu vereinfachen ts = ts.replace('MESZ', '').replace('MEZ', '').replace('UTC', '').strip() # Liste gängiger Zeitstempel-Formate formate = [ '%d.%m.%Y, %H:%M:%S', '%d.%m.%Y, %H:%M', '%Y-%m-%d, %H:%M:%S', '%Y-%m-%d, %H:%M', '%d/%m/%Y, %H:%M:%S', '%d/%m/%Y, %H:%M', '%Y/%m/%d, %H:%M:%S', '%Y/%m/%d, %H:%M', '%d.%m.%Y %H:%M:%S', '%d.%m.%Y %H:%M', '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M', '%d/%m/%Y %H:%M:%S', '%d/%m/%Y %H:%M', '%Y/%m/%d %H:%M:%S', '%Y/%m/%d %H:%M', ] for fmt in formate: try: return datetime.strptime(ts, fmt) except ValueError: continue # Fallback: Versuche, nur das Datum zu parsen datums_teile = re.findall(r'(\d{1,4}[./-]\d{1,2}[./-]\d{2,4})', ts) if datums_teile: for teil in datums_teile: for fmt in ['%d.%m.%Y', '%Y-%m-%d', '%d/%m/%Y', '%Y/%m/%d']: try: return datetime.strptime(teil, fmt) except ValueError: continue return None def extrahiere_beliebigen_zeitstempel(eintrag): """ Versucht, einen Zeitstempel aus beliebigen Feldern (timestamp, message etc.) zu extrahieren. Gibt (datetime-Objekt, Zeitstempel-String) zurück oder (None, None), falls nichts gefunden wird. """ kandidaten = [] # Prüfe bekannte Felder zuerst for schluessel in ['timestamp', 'message', 'content', 'text']: wert = eintrag.get(schluessel, '') if isinstance(wert, str) and wert.strip(): kandidaten.append(wert.strip()) # Suche nach Zeitstempel-Mustern in allen Werten des Eintrags for wert in eintrag.values(): if isinstance(wert, str): kandidaten.append(wert.strip()) # Regex für das primäre Zeitstempel-Format ts_regex = re.compile(r'(\d{2}\.\d{2}\.\d{4}, \d{2}:\d{2}:\d{2}(?: [A-Z]+)?)') for c in kandidaten: match = ts_regex.search(c) if match: ts_str = match.group(1) dt = versuche_zeitstempel_zu_parsen(ts_str) if dt: return dt, ts_str # Fallback: versuche, jeden Kandidaten-String vollständig zu parsen for c in kandidaten: dt = versuche_zeitstempel_zu_parsen(c) if dt: return dt, c return None, None def exportiere_chats_in_ordner(master_json_pfad, export_basis_verzeichnis): """ Exportiert alle Chat-Einträge aus der Master-JSON in eine Ordnerstruktur: Jahr/Monat/Tag/PromptX.txt. Unsortierte Einträge werden nach Fehlerursache in Unterordnern abgelegt. Erstellt zudem zentrale JSON- und TXT-Dateien zur Übersicht. """ # Lade die Master-JSON-Datei with open(master_json_pfad, 'r', encoding='utf-8') as f: data = json.load(f) chat_daten = data.get('gesamter_chatverlauf', {}) prompt_zaehler = {} unsortiert_zaehler = { 'Fehlender_Zeitstempel': 1, 'Falsches_Format': 1, 'Kein_String': 1, 'Sonstige_Fehler': 1 } # Listen zur Sammlung der Ergebnisse eintraege_2025 = [] eintraege_unsortiert = [] eintraege_bedeutungslos = [] alle_nachrichten_mit_zeit = [] ursprungs_worte = 0 exportierte_worte = 0 bedeutungslose_worte = 0 def ist_bedeutungslos(text): """Prüft, ob ein Text nur aus Leerzeichen, Satzzeichen oder gar keinem Inhalt besteht.""" if not text or not text.strip(): return True # Prüft, ob der String ausschließlich aus nicht-alphanumerischen Zeichen besteht if re.fullmatch(r'[\s\W_]+', text): return True return False # Zähle alle Worte im Ursprungs-JSON zur späteren Verifizierung for tages_eintraege in chat_daten.values(): if not isinstance(tages_eintraege, list): continue for eintrag in tages_eintraege: nachricht = eintrag.get('message', '') ursprungs_worte += len(re.findall(r'\w+', nachricht)) # Hauptschleife zur Verarbeitung aller Chat-Einträge for tages_eintraege in chat_daten.values(): if not isinstance(tages_eintraege, list): continue for eintrag in tages_eintraege: dt, ts_str = extrahiere_beliebigen_zeitstempel(eintrag) # Füge den Eintrag zur Liste für die spätere chronologische Sortierung hinzu eintrag_mit_zeit = dict(eintrag) eintrag_mit_zeit['__parsed_datetime'] = dt eintrag_mit_zeit['__parsed_timestamp'] = ts_str alle_nachrichten_mit_zeit.append(eintrag_mit_zeit) sprecher = eintrag.get('speaker', 'unbekannt') nachricht = eintrag.get('message', '') if ist_bedeutungslos(nachricht): eintraege_bedeutungslos.append(eintrag) bedeutungslose_worte += len(re.findall(r'\w+', nachricht)) continue # Wenn ein Zeitstempel gefunden wurde, sortiere in die Ordnerstruktur ein if dt: jahr = str(dt.year) monat = f"{dt.month:02d}" tag_str = f"{dt.day:02d}" ordner = os.path.join(export_basis_verzeichnis, jahr, monat, tag_str) os.makedirs(ordner, exist_ok=True) tages_schluessel = f"{jahr}-{monat}-{tag_str}" if tages_schluessel not in prompt_zaehler: prompt_zaehler[tages_schluessel] = 1 dateiname = f"Prompt{prompt_zaehler[tages_schluessel]}_{sprecher}.txt" prompt_zaehler[tages_schluessel] += 1 datei_pfad = os.path.join(ordner, dateiname) with open(datei_pfad, 'w', encoding='utf-8') as out: out.write(f"Timestamp: {ts_str}\nSpeaker: {sprecher}\n\n{nachricht}") exportierte_worte += len(re.findall(r'\w+', nachricht)) if jahr == '2025': eintraege_2025.append({"timestamp": ts_str, "speaker": sprecher, "message": nachricht}) # Wenn kein Zeitstempel gefunden wurde, sortiere in "Unsortiert" else: timestamp = eintrag.get('timestamp', None) if timestamp is None or (isinstance(timestamp, str) and not timestamp.strip()): gruppe = 'Fehlender_Zeitstempel' elif not isinstance(timestamp, str): gruppe = 'Kein_String' else: gruppe = 'Falsches_Format' gruppen_ordner = os.path.join(export_basis_verzeichnis, 'Unsortiert', gruppe) os.makedirs(gruppen_ordner, exist_ok=True) dateiname = f"Prompt{unsortiert_zaehler[gruppe]}_{sprecher}.txt" unsortiert_zaehler[gruppe] += 1 datei_pfad = os.path.join(gruppen_ordner, dateiname) with open(datei_pfad, 'w', encoding='utf-8') as out: out.write(f"Original-Timestamp: {timestamp}\nSpeaker: {sprecher}\n\n{nachricht}") exportierte_worte += len(re.findall(r'\w+', nachricht)) eintrag_kopie = dict(eintrag) if isinstance(eintrag, dict) else {} eintrag_kopie['gruppe'] = gruppe eintraege_unsortiert.append(eintrag_kopie) # Erstelle eine zentrale, chronologisch sortierte JSON-Datei aller Nachrichten alle_nachrichten_sortiert = sorted( [e for e in alle_nachrichten_mit_zeit if e['__parsed_datetime'] is not None], key=lambda e: e['__parsed_datetime'] ) # Konvertiere datetime-Objekte zu Strings für die JSON-Speicherung def konvertiere_datetimes(obj): if isinstance(obj, dict): return {k: (v.isoformat() if isinstance(v, datetime) else v) for k, v in obj.items()} return obj alle_nachrichten_sortiert_serialisierbar = [konvertiere_datetimes(e) for e in alle_nachrichten_sortiert] alle_json_sortiert_pfad = os.path.join(export_basis_verzeichnis, 'ALLE_NACHRICHTEN_SORTIERT.json') with open(alle_json_sortiert_pfad, 'w', encoding='utf-8') as f: json.dump(alle_nachrichten_sortiert_serialisierbar, f, indent=2, ensure_ascii=False) # Erstelle Zusammenfassungsdateien für das Jahr 2025 ordner_2025 = os.path.join(export_basis_verzeichnis, '2025') if eintraege_2025 and os.path.exists(ordner_2025): # Sortiere die 2025er Einträge chronologisch eintraege_2025_sortiert = sorted( eintraege_2025, key=lambda e: (versuche_zeitstempel_zu_parsen(e.get('timestamp','')) or datetime.max) ) with open(os.path.join(ordner_2025, '2025_gesamt.txt'), 'w', encoding='utf-8') as f: for e in eintraege_2025_sortiert: f.write(f"Timestamp: {e['timestamp']}\nSpeaker: {e['speaker']}\n{e['message']}\n---\n") with open(os.path.join(ordner_2025, '2025_gesamt.json'), 'w', encoding='utf-8') as f: json.dump(eintraege_2025_sortiert, f, indent=2, ensure_ascii=False) # Erstelle Zusammenfassungsdateien für unsortierte Einträge ordner_unsortiert = os.path.join(export_basis_verzeichnis, 'Unsortiert') if eintraege_unsortiert and os.path.exists(ordner_unsortiert): with open(os.path.join(ordner_unsortiert, 'Unsortiert_gesamt.txt'), 'w', encoding='utf-8') as f: for e in eintraege_unsortiert: f.write(f"Gruppe: {e.get('gruppe', 'unbekannt')}\nOriginal-Timestamp: {e.get('timestamp')}\nSpeaker: {e.get('speaker')}\n{e.get('message')}\n---\n") with open(os.path.join(ordner_unsortiert, 'Unsortiert_gesamt.json'), 'w', encoding='utf-8') as f: json.dump(eintraege_unsortiert, f, indent=2, ensure_ascii=False) # Schreibe bedeutungslose Prompts in eine separate Datei if eintraege_bedeutungslos: bedeutungslos_pfad = os.path.join(export_basis_verzeichnis, 'Bedeutungslose_Prompts.json') with open(bedeutungslos_pfad, 'w', encoding='utf-8') as f: json.dump(eintraege_bedeutungslos, f, indent=2, ensure_ascii=False) # Erstelle eine Verifizierungsdatei, um die Wortanzahl zu vergleichen verif_pfad = os.path.join(export_basis_verzeichnis, 'Verifizierung_Wortanzahl.txt') summe_exportiert = exportierte_worte + bedeutungslose_worte verhaeltnis = ursprungs_worte / summe_exportiert if summe_exportiert > 0 else 0 with open(verif_pfad, 'w', encoding='utf-8') as f: f.write(f"Wörter in Originaldaten: {ursprungs_worte}\n") f.write(f"Wörter in exportierten Dateien (sortiert + unsortiert): {exportierte_worte}\n") f.write(f"Wörter in bedeutungslosen Prompts: {bedeutungslose_worte}\n") f.write(f"Summe aller exportierten Wörter: {summe_exportiert}\n") f.write(f"Verhältnis Original / Export: {verhaeltnis:.5f}\n") if abs(1.0 - verhaeltnis) > 0.001: f.write(f"\n[WARNUNG] Es gibt eine Abweichung in der Wortanzahl von {abs(1.0 - verhaeltnis)*100:.3f}%. Möglicherweise ein Fehler beim Parsen.\n") else: f.write("\n[OK] Lückenlose Extraktion der Wörter!\n") print(f"[ERFOLG] Export abgeschlossen. Daten befinden sich im Ordner: {export_basis_verzeichnis}") def hole_naechstes_export_verzeichnis(skript_verzeichnis, skript_name): """Erzeugt einen eindeutigen Namen für den Export-Ordner, um alte Exporte nicht zu überschreiben.""" basis_export_verzeichnis = os.path.join(skript_verzeichnis, f"{skript_name}_export") export_verzeichnis = basis_export_verzeichnis index = 1 while os.path.exists(export_verzeichnis): export_verzeichnis = f"{basis_export_verzeichnis}_{index}" index += 1 return export_verzeichnis if __name__ == "__main__": try: # Bestimme das Verzeichnis, in dem das Skript ausgeführt wird skript_verzeichnis = os.path.dirname(os.path.abspath(__file__)) # Name der Eingabedatei master_json = os.path.join(skript_verzeichnis, 'Master_Chronik_V10_FINAL.json') # Erzeuge einen eindeutigen Namen für den Export-Ordner skript_name = os.path.splitext(os.path.basename(__file__))[0] export_verzeichnis = hole_naechstes_export_verzeichnis(skript_verzeichnis, skript_name) # Starte die Hauptfunktion exportiere_chats_in_ordner(master_json, export_verzeichnis) except FileNotFoundError: print(f"\n[FEHLER] Die Datei '{master_json}' wurde nicht gefunden.") print("Stelle sicher, dass sie sich im selben Ordner wie das Skript befindet und der Name korrekt ist.") except Exception as e: print(f"\n[KRITISCHER FEHLER] Ein unerwarteter Fehler ist aufgetreten: {e}")