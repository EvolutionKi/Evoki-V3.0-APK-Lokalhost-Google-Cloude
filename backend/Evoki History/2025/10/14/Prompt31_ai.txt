Timestamp: 14.10.2025, 04:07:36 MESZ
Speaker: ai

Absolut, das sind die fehlenden Puzzleteile. Wir haben jetzt alle Python- Module (die "Organe"), aber wir brauchen noch die Dateien, die das System zum Leben erwecken: app.py (Das "Gehirn" / der Server) index.html (Das "Gesicht" / die Weboberfl√§che) requirements.txt (Die "Einkaufsliste" f√ºr die Installation) Hier sind die vollst√§ndigen, finalen Versionen dieser drei Dateien. Sie sind exakt darauf ausgelegt, mit den modularen Skripten zu arbeiten, die wir gerade erstellt haben. 1. Die app.py Datei (Der Server) Diese Datei ist der Startpunkt deiner Anwendung. Sie importiert die ChrononEngine , startet den Webserver, definiert die Endpunkte f√ºr Upload, Download und Chat und stellt die Verbindung zur index.html her. Anleitung: Erstelle eine neue Datei mit dem Namen app.py und f√ºge den folgenden, vollst√§ndigen Code ein. # Dateiname: app.py # Zweck: Der Flask-Webserver, der als zentraler Einstiegspunkt f√ºr die Anwendung dient. import os from flask import Flask, request, jsonify, send_from_directory, render_template_string from werkzeug.utils import secure_filename import google.generativeai as genai # Importiere die Hauptklasse aus unserem modularen System from chronon_engine import ChrononEngine, SystemCriticalError # --- Konfiguration --- # 1. Speicherort: Definiert, wo die persistenten Daten gespeichert werden. # In der Cloud zeigt dies auf eine gemountete Festplatte. STORAGE_DIR = os.environ.get('EVC_STORAGE_DIR', 'evoki_festspeicher') PERSISTENT_FILENAME = "evoki_data.json" FALLSTUDIE_FILENAME = "fallstudie_evoki.txt" STORAGE_FILEPATH = os.path.join(STORAGE_DIR, PERSISTENT_FILENAME) ALLOWED_EXTENSIONS = {'json', 'txt'} app = Flask(__name__) # Stellt sicher, dass das Speicherverzeichnis beim Start existiert os.makedirs(STORAGE_DIR, exist_ok=True) # --- Initialisierung der Engine --- # 2. API-Schl√ºssel: L√§dt den Schl√ºssel sicher aus der Umgebungsvariable des Servers. GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY') if not GEMINI_API_KEY: # Das Programm wird nicht starten, wenn der Schl√ºssel fehlt. raise ValueError("FATAL: Die Umgebungsvariable 'GEMINI_API_KEY' wurde nicht gefunden!") genai.configure(api_key=GEMINI_API_KEY) # 3. Engine-Instanz: Die ChrononEngine wird EINMAL beim Serverstart erstellt. try: evoki_engine = ChrononEngine(storage_filepath=STORAGE_FILEPATH) except Exception as e: evoki_engine = None print(f"FATALER FEHLER: Die Evoki Engine konnte nicht gestartet werden: {e}") def allowed_file(filename): """Pr√ºft, ob eine Datei eine erlaubte Endung hat.""" return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS # --- Routen / Endpunkte --- @app.route('/') def index(): """Zeigt die Hauptseite (index.html) an.""" try: with open("index.html", "r", encoding="utf-8") as f: return render_template_string(f.read()) except FileNotFoundError: return "Fehler: index.html nicht gefunden. Stelle sicher, dass sie im selben Verzeichnis liegt.", 404 @app.route('/upload', methods=['POST']) def upload_file(): """Nimmt eine Fallstudien-Datei (.txt) entgegen und speichert sie.""" if 'fallstudie' not in request.files: return jsonify(error="Kein Dateiteil im Request gefunden."), 400 file = request.files['fallstudie'] if file.filename == '' or not allowed_file(file.filename): return jsonify(error="Keine g√ºltige .txt-Datei ausgew√§hlt."), 400 try: filepath = os.path.join(STORAGE_DIR, FALLSTUDIE_FILENAME) file.save(filepath) print(f"Fallstudie erfolgreich gespeichert unter: {filepath}") if evoki_engine: evoki_engine.lade_fallstudie_als_kontext() # Engine anweisen, die neue Datei zu laden return jsonify(message=f"Fallstudie erfolgreich hochgeladen."), 200 except Exception as e: return jsonify(error=f"Interner Fehler beim Speichern: {e}"), 500 @app.route('/download') def download_file(): """Stellt die Fallstudien-Datei zum Download bereit.""" try: return send_from_directory(STORAGE_DIR, FALLSTUDIE_FILENAME, as_attachment=True) except FileNotFoundError: return "Fehler: Es wurde noch keine Fallstudie hochgeladen.", 404 @app.route('/interact', methods=['POST']) def interact(): """Der Haupt-Endpunkt f√ºr die Chat-Kommunikation.""" if not evoki_engine: return jsonify({'response': 'FEHLER: Die EVOKI Engine ist nicht betriebsbereit.'}), 500 user_input = request.json.get('message', '').strip() if not user_input: return jsonify({'response': 'Leere Anfrage erhalten.'}), 400 try: # Die Engine verarbeitet die Anfrage und gibt ein Dictionary zur√ºck result = evoki_engine.process_interaction(user_input) # F√ºge das finale Statusfenster zur Antwort hinzu full_response_text = f"{result.get('response', '')}\n\n{result.get('status_window', '')}" return jsonify({'response': full_response_text, 'token_count': result.get('token_count', 0)}) except Exception as e: print(f"FEHLER bei der Interaktion: {e}") return jsonify({'response': 'Ein interner Serverfehler ist aufgetreten.'}), 500 if __name__ == '__main__': # Dieser Block wird nur ausgef√ºhrt, wenn du das Skript lokal startest (z.B. f√ºr Tests) app.run(host="0.0.0.0", port=int(os.environ.get("PORT", 8080)), debug=True) 2. Die index.html Datei (Die Benutzeroberfl√§che) Dies ist die Weboberfl√§che, die der Nutzer sieht. Sie wurde angepasst, um die Upload/Download-Funktionen und die Token-Anzeige zu integrieren. Sie kommuniziert ausschlie√ülich mit deiner app.py . Anleitung: Erstelle eine neue Datei mit dem Namen index.html und f√ºge den folgenden, vollst√§ndigen Code ein. <!DOCTYPE html> <html lang="de"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>EVOKI V5 - Modulares Interface</title> <script src="https://cdn.tailwindcss.com"></script> <style> body { font-family: 'Inter', sans-serif, system-ui; } #chat-messages { scroll-behavior: smooth; } .chat-bubble { max-width: 90%; word-wrap: break-word; } .chat-bubble-user { background-color: #DBEAFE; color: #1E3A8A; } .chat-bubble-ai { background-color: #F1F5F9; color: #1E293B; white-space: pre-wrap; } #chat-input { resize: none; } </style> </head> <body class="bg-gray-200 flex items-center justify-center min-h-screen p-4"> <div class="w-full max-w-4xl h-[95vh] flex flex-col bg-white rounded-2xl shadow-lg"> <header class="p-4 border-b border-gray-200"> <h1 class="text-2xl font-bold text-gray-800 text-center">EVOKI System V5</h1> <div class="mt-4 p-4 bg-gray-50 rounded-lg border flex flex-col sm:flex-row items-center justify-center gap-4"> <h2 class="font-semibold text-gray-700">Fallstudien-Verwaltung:</h2> <input type="file" id="file-input" class="hidden" accept=".txt"/> <button onclick="document.getElementById('file-input').click()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg text-sm"> üìÅ Fallstudie ausw√§hlen... </button> <button id="upload-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg text-sm"> Hochladen </button> <a href="/download" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg text-sm no-underline"> üì• Aktuelle Version herunterladen </a> </div> <p id="upload-status" class="text-center text-sm text-gray-500 mt-2 h-4"></p> </header> <main id="chat-messages" class="flex-1 p-6 space-y-4 overflow-y-auto"> <div class="flex justify-start"> <div class="chat-bubble chat-bubble-ai rounded-lg p-3"> System initialisiert. Ich bin bereit f√ºr deine Anweisungen. </div> </div> </main> <footer class="p-4 border-t border-gray-200"> <form id="chat-form" class="flex items-center gap-2"> <textarea id="chat-input" placeholder="Nachricht an EVOKI..." class="flex-grow p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500" rows="1"></textarea> <button type="submit" class="bg-indigo-600 text-white rounded-lg p-3 h-12 w-12 flex items-center justify-center hover:bg-indigo-700 disabled:bg-gray-400 transition-colors"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6"><path d="M3.478 2.404a.75.75 0 0 0-.926.941l2.432 7.905H13.5a.75.75 0 0 1 0 1.5H4.984l-2.432 7.905a.75.75 0 0 0 .926.94 60.519 60.519 0 0 0 18.445-8.986.75.75 0 0 0 0-1.218A60.517 60.517 0 0 0 3.478 2.404Z" /></svg> </button> </form> </footer> </div> <script> const chatForm = document.getElementById('chat-form'); const chatInput = document.getElementById('chat-input'); const chatMessages = document.getElementById('chat-messages'); const submitButton = chatForm.querySelector('button'); const uploadButton = document.getElementById('upload-button'); const fileInput = document.getElementById('file-input'); const uploadStatus = document.getElementById('upload-status'); function addMessage(sender, message, tokenCount = null) { const messageContainer = document.createElement('div'); messageContainer.className = `flex flex-col ${sender === 'user' ? 'items-end' : 'items-start'}`; const bubble = document.createElement('div'); bubble.className = `chat-bubble rounded-lg p-3 ${sender === 'user' ? 'chat-bubble-user' : 'chat-bubble-ai'}`; bubble.textContent = message; messageContainer.appendChild(bubble); if (tokenCount !== null && tokenCount > 0) { const tokenInfo = document.createElement('div'); tokenInfo.className = 'text-xs text-gray-400 mt-1 px-1'; tokenInfo.textContent = `ü™ô Tokens: ${tokenCount}`; messageContainer.appendChild(tokenInfo); } chatMessages.appendChild(messageContainer); chatMessages.scrollTop = chatMessages.scrollHeight; } chatForm.addEventListener('submit', async (event) => { event.preventDefault(); const userInput = chatInput.value.trim(); if (!userInput) return; addMessage('user', userInput); chatInput.value = ''; submitButton.disabled = true; const loadingBubble = document.createElement('div'); loadingBubble.id = 'loading'; loadingBubble.className = 'flex justify-start'; loadingBubble.innerHTML = `<div class="chat-bubble chat-bubble-ai rounded-lg p-3"><span class="animate-pulse">Denke nach...</span></div>`; chatMessages.appendChild(loadingBubble); chatMessages.scrollTop = chatMessages.scrollHeight; try { const response = await fetch('/interact', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: userInput }), }); const data = await response.json(); if (!response.ok) throw new Error(data.response || 'Serverfehler'); loadingBubble.remove(); addMessage('ai', data.response, data.token_count); } catch (error) { loadingBubble.remove(); addMessage('ai', `Fehler: ${error.message}`); } finally { submitButton.disabled = false; chatInput.focus(); } }); uploadButton.addEventListener('click', async () => { const file = fileInput.files[0]; if (!file) { uploadStatus.textContent = 'Bitte zuerst eine .txt-Datei ausw√§hlen.'; return; } const formData = new FormData(); formData.append('fallstudie', file); uploadStatus.textContent = 'Lade hoch...'; try { const response = await fetch('/upload', { method: 'POST', body: formData }); const result = await response.json(); if (!response.ok) throw new Error(result.error || 'Unbekannter Fehler'); uploadStatus.textContent = `Erfolg: ${result.message}`; } catch (error) { uploadStatus.textContent = `Fehler beim Upload: ${error.message}`; } }); chatInput.addEventListener('input', () => { chatInput.style.height = 'auto'; chatInput.style.height = (chatInput.scrollHeight) + 'px'; }); </script> </body> </html> 3. Die requirements.txt Datei (Die Installationsanleitung) Diese kleine, aber wichtige Datei sagt dem Server, welche Python-Bibliotheken er installieren muss, damit dein Code l√§uft. Anleitung: Erstelle eine neue Datei mit dem Namen requirements.txt und f√ºge den folgenden Text ein. Flask numpy gunicorn google-generativeai werkzeug