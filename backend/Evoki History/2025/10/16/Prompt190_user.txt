Timestamp: 16.10.2025, 12:21:32 MESZ
Speaker: user

#!/usr/bin/env python3 import sys, re, textwrap from pathlib import Path def patch_file(path: Path): code = path.read_text(encoding="utf-8") # 1) Insert ExternalNotesClient after NotizClientStub pat_stub_end = r"(class NotizClientStub:[\s\S]+?\n)\s*class FileStorageAdapter" m = re.search(pat_stub_end, code) if not m: raise SystemExit("FEHLER: Konnte das Ende von NotizClientStub nicht finden.") before = code[:m.start(0)] stub_block = code[m.start(1):m.end(1)] rest = code[m.end(1):] external_client_block = ''' class ExternalNotesClient: \"\" Adapter fÃ¼r die externe Notes-API. Erwartet ein Modul `notes_and_lists` mit Funktion: notes_and_lists.create_note(title: str, text_content: str) -> Any \"\" def __init__(self): try: import notes_and_lists # type: ignore except Exception as e: raise ImportError(f"External Notes API nicht verfÃ¼gbar: {e}") self._mod = notes_and_lists def append_note(self, title: str, content: str): try: self._mod.create_note(title=title, text_content=content) except TypeError: self._mod.create_note(title=title, text=content) ''' code = before + stub_block + "\n" + external_client_block + "\nclass FileStorageAdapter" + rest.split("class FileStorageAdapter",1)[1] # 2) Replace Notes init in FileStorageAdapter.__init__ init_pattern = r"# Notizzettel-API Konfiguration\s*\n\s*env_enabled = .*?\n\s*self\._notiz_enabled = .*?\n\s*self\._notiz_client = .*?\n" new_init_block = textwrap.dedent(''' # Notizzettel-API Konfiguration (extern bevorzugt, sonst Stub via Env) self._notiz_enabled = False self._notiz_client = None try: # Externe API (notes_and_lists) bevorzugen self._notiz_client = ExternalNotesClient() self._notiz_enabled = True logger.info("NotesAPI: Externe Notes-API aktiviert (ExternalNotesClient).") except Exception as e: # Fallback: aktivierbarer Stub Ã¼ber Env env_enabled = os.environ.get("NOTIZ_API_ENABLED", "").strip() == "1" or bool(os.environ.get("NOTIZ_API_URL")) if env_enabled: self._notiz_client = NotizClientStub(storage_path) self._notiz_enabled = True logger.warning(f"NotesAPI: Extern nicht verfÃ¼gbar ({e}). Stub aktiviert (ENV).") else: logger.warning(f"NotesAPI: Extern nicht verfÃ¼gbar ({e}). Notes-API bleibt OFF.") ''') code, nsubs = re.subn(init_pattern, new_init_block, code, flags=re.MULTILINE) if nsubs == 0: raise SystemExit("FEHLER: Konnte den Notes-Init-Block in FileStorageAdapter.__init__ nicht ersetzen.") # 3) Persist full outputs inside ChrononEngine._generate_statusfenster_A61 status_pat = r'(def _generate_statusfenster_A61\([\s\S]+?status_str\s*=\s*".+?join\(.*?\)\s*\n\s*return status_str)' m = re.search(status_pat, code) if not m: status_pat = r'(def _generate_statusfenster_A61\([\s\S]+?status_str\s*=\s*".+?"[\s\S]+?\n\s*return status_str)' m = re.search(status_pat, code) if not m: raise SystemExit("FEHLER: Konnte _generate_statusfenster_A61 nicht zuverlÃ¤ssig parsen.") block = m.group(0) insertion_note = textwrap.dedent(''' # Externe Persistenz der Ausgabe (vollstÃ¤ndiger Text dieser Ausgabe) try: notes_available, _, _ = self.storage.snapshot_notes_usage(reset=False) if notes_available and self.storage._notiz_client: from datetime import datetime, timezone note_title = f"Evoki Interaktion {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')}" full_text = response_text + "\n\n--- STATUS ---\n" + status_str try: self.storage._notiz_client.append_note(title=note_title, content=full_text) try: self.storage._mark_notes_used("out") except Exception: pass except Exception: try: self.storage._mark_notes_error() except Exception: pass except Exception: pass ''') block_new = block.replace("return status_str", insertion_note + " return status_str") code = code.replace(block, block_new) # Write backup and file backup = path.with_suffix(path.suffix + ".bak") backup.write_text(path.read_text(encoding="utf-8"), encoding="utf-8") path.write_text(code, encoding="utf-8") print(f"Patch angewendet. Backup: {backup.name}") def main(): if len(sys.argv) != 2: print("Verwendung: python apply_extnotes_patch.py /pfad/zu/evoki_engine_prod_clean.py") sys.exit(1) target = Path(sys.argv[1]).expanduser() if not target.exists(): print(f"FEHLER: Datei nicht gefunden: {target}") sys.exit(2) patch_file(target) if __name__ == "__main__": main()