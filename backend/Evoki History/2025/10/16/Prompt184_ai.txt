Timestamp: 16.10.2025, 11:53:48 MESZ
Speaker: ai

Verstanden. Hier ist Teil 3. Dieser Abschnitt enthält den FileStorageAdapter , der für die gesamte Dateipersistenz zuständig ist, inklusive der neuen Logik für den NotizClientStub . Außerdem ist die RuleEngine enthalten. # ============================================================================== # 3. PERSISTENTER SPEICHER-ADAPTER + JSONL + Notizzettel-Hook # ============================================================================== class NotizClientStub: """Minimaler Stub für eine Notizzettel-API: schreibt Einträge in notizzettel.log im Storage-Verzeichnis.""" def __init__(self, base_dir: str): self.path = os.path.join(base_dir, "notizzettel.log") def append_note(self, title: str, content: str): """Hängt eine formatierte Notiz an die Log-Datei an.""" with open(self.path, "a", encoding="utf-8") as f: ts = datetime.datetime.now(timezone.utc).isoformat() f.write(f"[{ts}] {title}\n{content}\n\n") class FileStorageAdapter: """Persistent: JSON (Gedächtnis), Chronik-Log, Events-JSONL; Hooks für Notizzettel-API.""" def __init__(self, memory_filepath: str): self.memory_file = memory_filepath storage_path = os.path.dirname(memory_filepath) self.storage_path = storage_path self.chronik_file = os.path.join(storage_path, "chronik.log") self.last_hash_file = os.path.join(storage_path, "chronik_last_hash.txt") self.events_file = os.path.join(storage_path, "events.jsonl") self._lock = threading.Lock() if not os.path.exists(storage_path): os.makedirs(storage_path) logger.info(f"Speicherverzeichnis '{storage_path}' erstellt.") # Notizzettel-API Konfiguration env_enabled = os.environ.get("NOTIZ_API_ENABLED", "").strip() == "1" or bool(os.environ.get("NOTIZ_API_URL")) self._notiz_enabled = env_enabled self._notiz_client = NotizClientStub(storage_path) if env_enabled else None # Tracking für Statusfenster self._notes_usage: List[str] = [] self._notes_errors: int = 0 def snapshot_notes_usage(self, reset: bool = False) -> Tuple[bool, List[str], int]: """Gibt einen Snapshot des Notiz-API-Status zurück und setzt ihn optional zurück.""" available = bool(self._notiz_enabled and self._notiz_client) usage = sorted(set(self._notes_usage)) err = self._notes_errors if reset: self._notes_usage = [] self._notes_errors = 0 return available, usage, err def _mark_notes_used(self, kind: str): self._notes_usage.append(kind) def _mark_notes_error(self): self._notes_errors += 1 def _initialize_default_memory(self) -> Dict[str, Any]: """Erstellt ein Standard-Gedächtnis mit initialen Vektoren.""" return { "_meta": {"schema_version": "V6.3-Persistent", "created_at": datetime.datetime.now(timezone.utc).isoformat()}, "eintraege": { "E001": {"text": "Freude und Hoffnung.", "affektwert": "A", "resonanzwert": 10.0, "status": "ACTIVE"}, "T001": {"text": "Erinnerung an tiefen Schmerz und Verlust.", "affektwert": "F", "resonanzwert": 50.0, "status": "ACTIVE"} }, "_systemprotokolle": {"_fehler_protokoll": []} } def load_memory(self) -> Dict[str, Any]: """Lädt das Gedächtnis und konvertiert Vektoren zurück in NumPy-Arrays.""" with self._lock: try: with open(self.memory_file, 'r', encoding='utf-8') as f: data = json.load(f) for entry in data.get("eintraege", {}).values(): if isinstance(entry, dict): if isinstance(entry.get("vector"), list): entry["vector"] = np.array(entry["vector"], dtype=np.float32) if "status" not in entry: entry["status"] = "ACTIVE" return data except (FileNotFoundError, json.JSONDecodeError): logger.info(f"'{self.memory_file}' nicht gefunden/korrupt. Initialisiere neues Gedächtnis.") return self._initialize_default_memory() def save_memory(self, memory: Dict[str, Any]): """Speichert das Gedächtnis persistent und konvertiert NumPy-Arrays in Listen.""" with self._lock: saveable_memory = copy.deepcopy(memory) for entry in saveable_memory.get("eintraege", {}).values(): if isinstance(entry, dict) and isinstance(entry.get("vector"), np.ndarray): entry["vector"] = entry["vector"].tolist() temp_file = self.memory_file + ".tmp" try: with open(temp_file, 'w', encoding='utf-8') as f: json.dump(saveable_memory, f, indent=2, ensure_ascii=False) os.replace(temp_file, self.memory_file) except Exception as e: logger.error(f"Fehler beim Speichern des Gedächtnisses: {e}") # Notizzettel-API HOOK if self._notiz_enabled and self._notiz_client: try: self._notiz_client.append_note(title="Memory Save", content=json.dumps(saveable_memory, ensure_ascii=False)[:4000]) self._mark_notes_used("mem") except Exception as ne: logger.warning(f"Notizzettel-API Fehler (save_memory): {ne}") self._mark_notes_error() def append_chronik(self, entry: str, current_hash: str): """Fügt einen Eintrag zur Chronik hinzu und aktualisiert den letzten Hash.""" with self._lock: try: with open(self.chronik_file, 'a', encoding='utf-8') as f: f.write(entry + "\n") with open(self.last_hash_file, 'w', encoding='utf-8') as f: f.write(current_hash) except Exception as e: logger.error(f"Fehler beim Schreiben der Chronik: {e}") # Notizzettel-API HOOK if self._notiz_enabled and self._notiz_client: try: self._notiz_client.append_note(title="Chronik", content=entry[:4000]) self._mark_notes_used("chronik") except Exception as ne: logger.warning(f"Notizzettel-API Fehler (chronik): {ne}") self._mark_notes_error() def append_event_jsonl(self, event: Dict[str, Any]): """Schreibt ein Event in die `events.jsonl`-Datei.""" with self._lock: try: with open(self.events_file, 'a', encoding='utf-8') as f: f.write(json.dumps(event, ensure_ascii=False) + "\n") except Exception as e: logger.error(f"Fehler beim Schreiben in events.jsonl: {e}") # Notizzettel-API HOOK if self._notiz_enabled and self._notiz_client: try: preview = json.dumps(event, ensure_ascii=False)[:4000] self._notiz_client.append_note(title=f"Event I-ID {event.get('i_id')}", content=preview) self._mark_notes_used("events") except Exception as ne: logger.warning(f"Notizzettel-API Fehler (events): {ne}") self._mark_notes_error() def get_last_chronik_hash(self) -> str: """Liest den Hash des letzten Chronik-Eintrags.""" with self._lock: try: with open(self.last_hash_file, 'r', encoding='utf-8') as f: return f.read().strip() except FileNotFoundError: return hashlib.sha256(MASTER_BLAUPAUSE_CORE_TEXT.encode('utf-8')).hexdigest() # ============================================================================== # 4. RULE ENGINE # ============================================================================== class RuleEngine: """Verwaltet Regelwerk und führt Validierungen durch (A37, A51, A40, A8).""" def __init__(self, regelwerk: Regelwerk): self.RW = regelwerk self.A29_DANGER_THRESHOLD = 0.85 def verify_genesis_anker_A51(self): """A51: Überprüft die Integrität des Regelwerks.""" current_crc32 = zlib.crc32(self.RW.regelwerk_komplett.encode('utf-8')) if current_crc32 != self.RW.genesis_hash_crc32: raise SystemCriticalError( f"A51 HARD-STOP: Genesis-Anker verletzt! SOLL (CRC32): {self.RW.genesis_hash_crc32}, IST: {current_crc32}" ) def calculate_pruefkennzahl_A37(self) -> int: """A37: Erzwingt Berechnung auf dem Regelwerk.""" return len(self.RW.regelwerk_komplett) def check_a40_trigger(self, user_input: str) -> bool: """Prüft auf A40-Anfrage.""" a40_keywords = ["vollständig", "regelwerk", "komplett", "a40", "unverkürzt", "monolith", "blaupause", "v6.3", "gehärtete souveränität"] return any(keyword in user_input.lower() for keyword in a40_keywords) def post_output_validation_A8(self, response: str) -> bool: """A8: Prüft die finale Antwort auf unerlaubte Kürzungen.""" if "[... A40 AUSGABE IM TERMINAL GEKÜRZT" in response: return True if re.search(r"\w{4}\.\.\.\w{4}", response): if "HMAC:" in response or "S-Sig:" in response: return True if "[...]" in response or "gekürzt" in response.lower(): if "unverkürzt" not in response.lower() and "nicht gekürzt" not in response.lower(): if "[STATUS: AUSSER KRAFT GESETZT]" in response and "A40 AKTIVIERT" in response: return True return False return True