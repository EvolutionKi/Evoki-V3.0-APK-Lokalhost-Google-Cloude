Timestamp: 06.10.2025, 15:20:30 MESZ
Speaker: ai

Ja, klar. Hier ist der Code mit der strengeren Filterung. Ich hab eine neue Funktion eingebaut, die genau wie dein Python-Skript nicht nur leere Zeilen, sondern auch "Daten-Schrott" – also Zeilen, die nur aus Satzzeichen oder Symbolen ohne Buchstaben oder Zahlen bestehen – erkennt und rauswirft. Die Bedienung bleibt gleich. Datei auswählen, Knopf drücken, fertig. Das Ergebnis sollte jetzt nur noch die wirklich relevanten Einträge enthalten. Code mit verbesserter Filterung <!DOCTYPE html> <html lang="de"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>TXT zu JSON (Strikter Filter)</title> <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script> <style> body { font-family: sans-serif; background-color: #222; color: #eee; padding: 20px; } .file-input-group, button { margin-bottom: 15px; } input, button { padding: 10px; font-size: 16px; width: 90%; max-width: 400px; display: block; } button { background-color: #007bff; color: #fff; border: none; cursor: pointer; } button:disabled { background-color: #555; cursor: not-allowed; } label { margin-bottom: 5px; display: block; } #status { margin-top: 20px; font-family: monospace; white-space: pre-wrap; background-color: #333; padding: 15px; border-radius: 5px; min-height: 50px; } </style> </head> <body> <h2>TXT zu JSON Strukturierer</h2> <div class="file-input-group"> <label for="aktivitaetenInput">Wähle deine "MeineAktivitätentxt.txt"</label> <input type="file" id="aktivitaetenInput" accept=".txt,text/plain"> </div> <button id="processBtn" onclick="run()">Strukturierte JSON-Datei erstellen</button> <h3>Status:</h3> <pre id="status">Warte auf deine Datei...</pre> <script> const processBtn = document.getElementById('processBtn'); const statusEl = document.getElementById('status'); function readFileAsText(file) { return new Promise((resolve, reject) => { if (!file) { reject(new Error("Keine Datei ausgewählt.")); return; } const reader = new FileReader(); reader.onload = (event) => resolve(event.target.result); reader.onerror = (error) => reject(error); reader.readAsText(file); }); } function tryParseTimestamp(ts) { if (typeof ts !== 'string' || !ts.trim()) return null; ts = ts.replace('MESZ', '').replace('MEZ', '').replace('UTC', '').trim(); const formats = [ 'DD.MM.YYYY, HH:mm:ss', 'DD.MM.YYYY, HH:mm', 'YYYY-MM-DD, HH:mm:ss', 'YYYY-MM-DD, HH:mm', 'DD.MM.YYYY HH:mm:ss', 'DD.MM.YYYY HH:mm', 'YYYY-MM-DD HH:mm:ss', 'YYYY-MM-DD HH:mm' ]; for (let fmt of formats) { let dt = moment(ts, fmt, true); if (dt.isValid()) return dt; } return null; } // NEU: Strikte Filterfunktion, die "is_bedeutungslos" aus Python nachbildet. function isMeaningless(text) { if (!text || !text.trim()) { return true; // Filtert leere oder nur aus Leerzeichen bestehende Strings. } // Prüft, ob der String mindestens EINEN Buchstaben oder EINE Zahl enthält. // Wenn nicht, ist er bedeutungslos (z.B. "..." oder "!?"). const hasMeaningfulChar = /\p{L}|\p{N}/u.test(text); return !hasMeaningfulChar; } function parseLineContent(line) { const match = line.match(/.*?(?:\d{2}:\d{2}:\d{2}):\s*([^:]+):\s*(.*)/); if (match) { const uhrzeitMatch = line.match(/(\d{2}:\d{2}:\d{2})/); return { uhrzeit: uhrzeitMatch ? uhrzeitMatch[1] : 'unbekannt', autor: match[1].trim(), nachricht: match[2].trim() }; } return { uhrzeit: 'unbekannt', autor: 'unbekannt', nachricht: line.trim() }; } async function run() { processBtn.disabled = true; statusEl.textContent = 'Starte Prozess...'; try { const aktivitaetenFile = document.getElementById('aktivitaetenInput').files[0]; statusEl.textContent = 'Lese Textdatei ein...'; const aktivitaetenText = await readFileAsText(aktivitaetenFile); statusEl.textContent = 'Filtere und sammle alle Einträge...'; const allEntries = []; aktivitaetenText.split('\n').forEach(line => { const timestamp = tryParseTimestamp(line); if (timestamp) { // Zeitstempel ist gültig, JETZT den Inhalt prüfen. const content = parseLineContent(line); // HIER wird der neue, strenge Filter auf die Nachricht angewendet. if (!isMeaningless(content.nachricht)) { allEntries.push({ timestamp, line }); } } }); if (allEntries.length === 0) { throw new Error("Keine sinnvollen Einträge mit gültigem Zeitstempel gefunden."); } statusEl.textContent = 'Sortiere den gesamten Verlauf chronologisch...'; allEntries.sort((a, b) => a.timestamp - b.timestamp); statusEl.textContent = 'Erstelle die JSON-Struktur...'; const structuredChat = {}; for (const entry of allEntries) { const year = entry.timestamp.format('YYYY'); const month = entry.timestamp.format('MM'); const day = entry.timestamp.format('DD'); if (!structuredChat[year]) structuredChat[year] = {}; if (!structuredChat[year][month]) structuredChat[year][month] = {}; if (!structuredChat[year][month][day]) structuredChat[year][month][day] = []; structuredChat[year][month][day].push(parseLineContent(entry.line)); } statusEl.textContent = 'Generiere finale JSON-Datei...'; const finalJsonString = JSON.stringify({ chatverlauf_strukturiert: structuredChat }, null, 2); const blob = new Blob([finalJsonString], { type: "application/json;charset=utf-8" }); saveAs(blob, "Aktivitaeten_strukturiert.json"); statusEl.textContent = `Fertig! ${allEntries.length} relevante Einträge verarbeitet. Download sollte starten.`; } catch (error) { statusEl.textContent = 'Fehler: ' as string + error.message; } finally { processBtn.disabled = false; } } </script> </body> </html>